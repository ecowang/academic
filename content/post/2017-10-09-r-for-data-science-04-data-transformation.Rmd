---
title: r for data science 04 data transformation
author: 王强
date: '2017-10-09'
slug: r-for-data-science-04-data-transformation
categories:
  - R
tags:
  - Data  transformation
  - R
draft: yes
---

[本章](http://r4ds.had.co.nz/transform.html)讲数据变形。

## 简介

通过数据可视化能够发现很多隐含的信息，但一般很难拿到数据能直接进行可视化，由于数据格式不对，要经过整理和变形，按某个变量排序，重命名变量或者增加新变量等操作。这些操作说起来简单，放到excel里点一点鼠标都有了，结合数据透视表也能实现这些目的。之所以要在R里也做这些，可以类比一下，美国已经有GPS系统了，我们为什么拼了命的还要搞北斗呢？不是一个系统，操作起来不顺手嘛。作为一个语言，应该能完成体系性的操作。这些操作原来在R的基础语句中，可以通过aply系列完成，但这个系列语句意思晦涩比较难以掌握，Hadley写了`dplyr`包以后,基本此类操作都是用他的函数。

### 5.1.1 预要求

本章主要介绍`dplyr`包的用法，次包是`tidyverse`系列包的一个重要组成，`tidyverse`是Hadley组织的一个系列包，里面主要包含他写的，也有几个其他的关于数据处理统计作图的包。这年头，大家都在建立生态圈，这个小小的统计领域也不例外，R通过开源聚集了一大批拥趸，而里面也有不同的流派和领域，`tidyverse`就是一个重要的，优质的流派。记得有一次Hadely讲座时候有人问他，这些包的功能能否纳入到R的基本功能里，他神秘的笑着，说，这不大可能。可能是我想多了，当时觉得，R的江湖也是波诡云谲啊，先到咸阳为王上，后来者哪怕再优秀，也要经过不断的斗争，形成气候才有可能受到招安。

回到`dplyr`包，练习数据使用`nycflights13`包，使用`ggplot2`来做图，帮助我们理解所完成的变形，和变形的目的。

```{r}
library(nycflights13)
library(tidyverse)
```

注意！载入`didyverse`以后，会有提示信息，说哪些函数把base R里的函数给覆盖了，基础包`stats`里有几个函数名和和本包里面重名，如`filter`和`lag`，如果还想要用基础包里的这俩函数，需要用`stats::filter()`和`stats::lag()`。当然一般用不着，因为，这几个函数比基础包里的好用太多了。

### 5.1.2 nycflights13

nycflights13包里面的flights，收集了纽约2013年336776架飞机的起飞降落飞行时间等信息。打出来看看是这样的。

```{r}
flights
```

如果之前接触过R，可以发现这个数据有点不一样，看着像数据框data frame，但上面写着个`tibble`。tibble是Hadley创造的一种数据格式，和数据框类似，但更加灵活，里面不但可以再套数据框，还可以套模型，几乎啥都能套进去。后面会有建模的问题，使用这个格式，能更方便地建模，后面会有更多了解。

数据的介绍里，仅对前面几列做了说明，如果要都看得用`View(flights)`。说明中有列的名称，和数据类型，数据类型包括以下这些。

* `int` stands for integers. 整数。

* `dbl` stands for doubles, or real numbers.实数，浮点。

* `chr` stands for character vectors, or strings.字符。

* `dttm` stands for date-times (a date + a time).日期+时间。

还有几种会遇到数据类型：

* `lgl` stands for logical, vectors that contain only `TRUE` or `FALSE`.逻辑变量。 

* `fctr` stands for factors, which R uses to represent categorical variables
  with fixed possible values.因子，即具有固定值得分类变量。

* `date` stands for dates.日期。

### dplyr 基础

主要学5个函数，包括：

* 按数值选择变量 (`filter()`)。比如我有一批树高的测量值，想只分析1999-2011年栽植的，就可以用这个函数进行筛选，函数名也很只管，filter，就是要按要求filter特定的行，相当于excel里，先按一列排序，然后再选择范围内的行。

* 排序 (`arrange()`)。类比excel，按某一列进行排序，可以正着排也可以倒着排。

* 按其名称选择变量 (`select()`)。

*  (`mutate()`)。这个太有用了，基于已有的变量，用函数产生新变量。

* 汇总统计值 (`summarise()`)。

重要的！以上函数都可以和一个伟大的函数合作使用——`group_by()`。这个函数能够进行不同的分组，然后让上面那些函数充分发挥作用。这非常5+1个函数弄熟了，数据基础操作就差不多了。

这些函数使用方式都很相似：

1.  第一个参数是要操作的数，一般以数据框的结构输入，可以是dataframe，最好是tibble。

1.  接下来是数据框的变量名，是函数具体要搞的对象。
    
1.  产出的结果都是数据框。

## 用 `filter()`，选择感兴趣的子数据框。

顾名思义，filter，就是用来筛选的，筛选出来形成一个新的数据框。如针对飞机数据，想选择1月1日起飞降落的飞机数据，可以这样写：

```{r}
filter(flights, month == 1, day == 1)
```

注意这里产生了新的数据框，但没有赋给任何一个对象，如要保存，需要自己定义赋值。可以用= 也可以用箭头。

```{r}
jan1 <- filter(flights, month == 1, day == 1) 
# 这个箭头的方向和等号相同。
```

如果我们想既赋值，又在控制器里显示出来，可以这样写，把语句放在括号里就行了：

```{r}
(dec25 <- filter(flights, month == 12, day == 25))
```

### 几个比较符号

要使用filter，肯定要界定条件，需要这几个比较符号：`>`, `>=`, `<`, `<=`, `!=` (不等于), and `==` (等于)。

注意， `=`，和`==`的区别。前一个是赋值，后一个才是等于，弄错了可能会有错误信息提示。

```{r, error = TRUE}
filter(flights, month = 1)
```

注意2，当涉及浮点数的时候，计算机算不准。看看开方以后再乘方，或者除不尽的再乘回去的结果：

```{r}
sqrt(2) ^ 2 == 2
1/49 * 49 == 1
```

因为这种情况下计算机存储的数，都是**近似值**！所以这种情况下，不要用`==`，要用`near()`。

```{r}
near(sqrt(2) ^ 2,  2)
near(1 / 49 * 49, 1)
```

### 逻辑符号（布林运算符）

数据集里各变量之互有关系，有时候要用逻辑符号进行精准选择。 如`&`是"和", `|` 是 "或", ， `!` 是 "非"。见下图：

![两个变量间的逻辑运算符](http://r4ds.had.co.nz/diagrams/transform-logical.png)


如选择11、12月的飞机：

```{r, eval = FALSE}
filter(flights, month == 11 | month == 12)
```

作者还提供了一种方式，是使用 `x %in% y`， 这会把所有y里有的x所在的行挑出来。下面代码和上面作用相同。

```{r, eval = FALSE}
nov_dec <- filter(flights, month %in% c(11, 12))
```


有时可以用De Morgan法则来记忆： `!(x & y)` 等价于 `!x | !y`,还有 `!(x | y)`等价于 `!x & !y`。

除了 `&` 和 `|`, R 还有 `&&` 和 `||`。这里还不会涉及，到[conditional execution]会有介绍。

### 缺失值

在R里面，缺失值很让人头疼，当然在其他体系里面也各有毛病，毕竟缺了，怎么处理都麻烦。 `NA`的意思是 ("not availables")，excel里的空白，读取到r里面就是NA。excel里也是凑合着把空白当成0。而在R里面，NA有传染性，涉及到的结果很多都会变成NA。

```{r}
NA > 5
10 == NA
NA + 10
NA / 2
```

更奇葩的结果是这个：

```{r}
NA == NA
```

如果想要知道一个值是否缺失，使用`is.na()`。

`filter()` 默认忽略 `FALSE` 和 `NA` 值，如果想要表现缺失值，要在函数中自行明确。

```{r}
df <- tibble(x = c(1, NA, 3))
filter(df, x > 1)
filter(df, is.na(x) | x > 1)
```

### 练习作业

1.  找到如下条件的飞机

    1. 晚点2小时及以上。
    
    ```{r}
filter(flights, arr_delay>=120)
    ```
    
    
    2. 飞往 Houston (`IAH` or `HOU`)
    
    ```{r}
filter(flights, dest=="IAH" | dest =="HOU")

filter(flights, dest %in% c("IAH", "HOU"))
```
    
    
    3. 由 United, American, 或 Delta运营
    
    ```{r}
airlines # 看缩写代表谁
filter(flights, carrier %in% c("UA", "AA", "DL"))
```
    
    
    4. 筛选7——9月的飞机班次。
    
    ```{r}
filter(flights, month %in% c(7,8,9))
```
    
    
    5. 起飞没有晚点，但到港晚点两小时以上。
    
    ```{r}
filter(flights, arr_delay > 120 & dep_delay <= 0)
```
    
    6. 起飞晚点一小时以上，但飞起来找补回来至少半小时。
    
    ```{r}
filter(flights, dep_delay >= 60 & (dep_delay - arr_delay) >= 30 )
```
    
    
    7. 凌晨到早上六点之间（含两头）起飞的飞机。
    
    ```{r}
filter(flights, dep_time >= 2400 | dep_time <= 600)

# 开始觉得应该从time_hour里提取控制值，不过搜了下两三个人都是这么写的，先这么滴吧。
```
    

1.  另一个和filter配合比较好的函数是 `between()`。它怎么用？你能否用它解决上面的问题吗？
    
    between(x, left, right) 在左右之间（含），比如可以
    
    ```{r}
filter(flights, between(arr_delay, 30, 60))
```
    

1.  数据里的 `dep_time`有多少缺失值？其他变量呢？这些含有缺失值的行如何表现？
    
    ```{r}
sum(is.na(flights$dep_time))

map_dbl(flights, ~ sum(is.na(.x)))
```
    

1.  为什么 `NA ^ 0` 不是缺失值？为什么 `NA | TRUE` 不是缺失值？为什么 `FALSE & NA` 不是缺失值？你能发现规律吗？(`NA * 0` 是个有趣的例子)


    `NA ^ 0`是1，因为任何值得0次方都是1。 `NA | TRUE`用`或|`连接，返回`TURE`，`FALSE & NA`用`且&`连接，则为FALSE。总结个规律，就是范围的大小关系的规律，FALSE最惨，一错啥都没有，NA好歹算个缺失值，TURE是相对最牛，所以这FALSE 和 NA 放一块按照比惨关系，TURE最牛。
  


## 用 `arrange()`对行排序

`arrange()` 和 `filter()` 使用方式相似，只不过功能不是筛选而是是排序。它用一列或多列进行排序，也可以用基于列的更复杂的计算式来排序。如果是用多列来排序，则按照优先级进行排列。

```{r}
arrange(flights, year, month, day)
#按照年、月、日进行排列，正序从小到大。
```

如果要倒序排列， 则用 `desc()` :

```{r}
arrange(flights, desc(arr_delay))
```

缺失值总是放在最后。

```{r}
df <- tibble(x = c(5, 2, NA))
arrange(df, x)
arrange(df, desc(x))
```



### Exercises

1.  用 `arrange()` 把缺失值排在前面。提示，用 `is.na()`。
    
    ```{r}
df <- tibble(x = c(5, 2, NA))
arrange(df, desc(is.na(x)), x)
# 用is.na() 先按得到的Ture和False排起来，然后再按照x排。
```
    
    
1.  对 `flights`，找到晚点最多的飞机，找到起飞最早的飞机。
    
    ```{r}
arrange(flights, desc(arr_delay))
arrange(flights, dep_delay) 
# 这里是比计划早。
```
    

1.  Sort `flights` to find the fastest flights.

    ```{r}
arrange(flights, desc(distance/air_time))
    
    # 距离除以时间，从大到小。
```


1.  Which flights travelled the longest? Which travelled the shortest?

    ```{r}
arrange(flights, desc(distance))
    arrange(flights, distance)
```
    

## 用 `select()`选择列

有时候我们会遇到很大的数据，有成百上千的变量，但只有少数是我们感兴趣的，这时候可以用`select()` 选择那些变量，方便地形成子数据集。这个过程是基于变量名进行的。

`select()` 在飞机数据里没有什么用武之地，毕竟只有19个变量，在此仅作示意。

```{r}
# 按变量名选择变量
select(flights, year, month, day)
# 选择year和day变量之间的所有变量
select(flights, year:day)
# 选择除了year和day之间数据的所有数据。
select(flights, -(year:day))
```


结合`select()`还有一些有用的函数。

* `starts_with("abc")`: 匹配以 "abc"开头的变量名。

* `ends_with("xyz")`: 匹配以"xyz"结尾的变量名。

* `contains("ijk")`: 匹配含 "ijk" 的变量名。

* `matches("(.)\\1")`: 匹配含表达式的变量名，如这个是匹配所有含有重复字符的变量。在字符一节还有介绍。
   
*  `num_range("x", 1:3)` 匹配 `x1`, `x2` 和 `x3`。

更多用法参见select函数说明。

此外，`select()`也可用于重命名变量，但一般不太用，因为它只保留重命名的那几列。变量重命名用`rename()`，只重命名，不改变其他。

```{r}
select(flights, tail_num = tailnum)
rename(flights, tail_num = tailnum)
# 新的在前面
```

另一个可能常会用到的函数是 `everything()`，如果想把选择出来的列放前面，其他列也保留着，可以这样做。

```{r}
select(flights, time_hour, air_time, everything())
```


### 练习

1.  头脑风暴，想出尽可能多的选择 `dep_time`, `dep_delay`,
    `arr_time`,和 `arr_delay` 的方法。
    
    ```{r, eval= FALSE}
select(flights, dep_time,  dep_delay, arr_time, arr_delay)
select(flights, c(dep_time,  dep_delay, arr_time, arr_delay))
flights %>% select(dep_time,  dep_delay, arr_time, arr_delay)

flights %>% select(matches("^dep|^arr"))
```
    
    
1.  在 `select()` 函数中，多次选择一个变量会怎么样？

    ```{r}
flights %>% select(dep_delay, dep_delay, dep_delay)
    # 和选一个效果一样。
```

  
1. 函数`one_of()` 的功能是什么？为什么对下面的文本向量的操作有用？
    
    ```{r}
    vars <- c("year", "month", "day", "dep_delay", "arr_delay")
    ```
    
    这是`dplyr`包里的一个函数，属于`select_helpers`家族的一份子，顾名思义，任何一个在文本向量里有的变量，都能选择出来（variables in character vector.）。
    
    ```{r}
    flights %>% select(one_of(vars))
    
    select(flights, one_of(vars))
    ```
    
    
1.  以下代码运行结果让你惊讶否？选择帮助默认如何处理这样的情况？你能如何改变默认设置？

    ```{r, eval = FALSE}
    select(flights, contains("TIME"))
    ```
    
    没有让我惊讶。可能作者想让我们认为这样会把变量名为“time”的变量选择出来，结果把所有里面含有”time“的都选出来。但contain意思本来就是含有，这样的结果很符合预期。如只想要time，则可以直接写，可以用match，也可以用one_of，当然用contain也可以，只需要把`contains(match, ignore.case = TRUE, vars = current_vars())`里面默认的ignore.case = TURE，改成FALSE就行了。此例中，没有这个变量：
    
    ```{r}
    select(flights, contains("TIME", ignore.case = FALSE))
    
    select(flights, "TIME")
    
    # 区别在于后面这个选不出来直接一个Error：Strings must match column names. Unknown columns: TIME。前面那样，产生一个多行0列的tibble。
    ```

## 使用`mutate()`函数，增加新变量

除了使用已有变量对数据集进行选择，很多时候也需要通过原有变量建立新变量，然后再基于新变量进行选择，函数 `mutate()`就是负责干这个活。mutate，就是改变，突变的意思。

`mutate()` 总是把新产生的变量放到数据集最后的列，飞机数据太宽，后面的列看不见，所以这里新做一个窄点的数据集。记住在Rstudio里面，查看全部数据最简单的方法就是使用`View()`另外注意，如果数据集太大，Rstudio在view后容易崩溃。

```{r}
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)
mutate(flights_sml,
  gain = arr_delay - dep_delay,
  speed = distance / air_time * 60
)
```

注意刚刚新建的变量，后面也可以纳入计算，如下面，刚新建的gain，后面就用上了。

```{r}
mutate(flights_sml,
  gain = arr_delay - dep_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

如果只想保留新建变量，则使用 `transmute()`:

```{r}
transmute(flights,
  gain = arr_delay - dep_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

### 常用新建变量的函数

结合 `mutate()`，有很多新建变量的函数可以使用。注意能使用的函数都是向量式的（must be vectorised），即：输入的是向量（老变量），输出的还是向量（新变量）。想把能用的函数都列出来肯定不可能，在此仅对常用的一些做一概述：

*   算术运算相关: `+`, `-`, `*`, `/`, `^`。这些都有向量式操作的特点，另外使用运算符的时候会有循环法则，即当两个向量长度不一时，短的自动循环到和长的一样长度（想想在excel里复制粘帖时候的状态），这个特点在涉及单一数字（也是个长度为一的向量）时很好用 ，如`air_time / 60`,
    `hours * 60 + minute`，等。
    
    运算符和汇总类函数（aggregate functions，后面还会学到）也可以配合使用。如`x / sum(x)`，计算占总数的比例，`y - mean(y)`计算的是和平均值得差别。
    
*   模块运算符（Modular arithmetic）: `%/%` (整除) 和 `%%` (求余数), 即：
    `x == y * (x %/% y) + (x %% y)`. 模块运算符是很有用的工具，因为它能够把除法中涉及的整数提取出来用如飞机数据中，可通过`dep_time` 计算`hour` 和 `minute` :
    
    ```{r}
    transmute(flights,
      dep_time,
      hour = dep_time %/% 60,
      minute = dep_time %% 60
    )
    # 原文中是除以100，按分钟应该是除以60吧？
    ```
  
*   对数系列: `log()`, `log2()`, `log10()`。 对数变换起码在两种情况极其有用：一是对付量级差别较大的数据，二是以后再模型一节还会提到的，把倍数关系转变为增减关系。
    
    几个转换方式差别不大，作者推荐使用`log2()`，因为解释起来比较容易：转换后刻度为1的就是原始数据加倍的，转换后为-1就是原始数据减半的。

*   抵消（Offsets）:`dplyr`包里的 `lead()` 和 `lag()`，可以计算前后移位值（leading or lagging 
    values）。这可以有利于计算 （running differences），例如`x - lag(x)`，或者发现数值变化(`x != lag(x))`。在配合 `group_by()`函数应用时尤为有用，稍后会学到。
    ```{r}
    (x <- 1:10)  # 写上括号就是即赋值又在控制台显示。
    lag(x)
    lead(x)
    ```
  
*   累积及循环汇总（Cumulative and rolling aggregates）:R基本包提供累积求和、product，最小值和最大值: `cumsum()`, `cumprod()`, `cummin()`, `cummax()`; dplyr包提供累积求平均值 `cummean()`。如果需要循环汇总(rolling
    aggregates)，例如 在 rolling window求和, 尝试 RcppRoll包。
    
    ```{r}
    x
    cumsum(x)
    cummean(x)
    ```

*   逻辑比较, `<`, `<=`, `>`, `>=`, `!=`, 之前学过。如果进行比较复杂的比较，最好新建中间变量，这样不容易出错且容易检查。

*   排序: there are a number of ranking functions, but you should 
    start with `min_rank()`. It does the most usual type of ranking 
    (e.g. 1st, 2nd, 2nd, 4th). The default gives smallest values the small
    ranks; use `desc(x)` to give the largest values the smallest ranks. 
    
    ```{r}
    y <- c(1, 2, 2, NA, 3, 4)
    min_rank(y)
    min_rank(desc(y))
    ```
    
    If `min_rank()` doesn't do what you need, look at the variants
    `row_number()`, `dense_rank()`, `percent_rank()`, `cume_dist()`,
    `ntile()`.  See their help pages for more details.
    
    ```{r}
    row_number(y)
    dense_rank(y)
    percent_rank(y)
    cume_dist(y)
    ```

### Exercises

```{r, eval = FALSE, echo = FALSE}
flights <- flights %>% mutate(
  dep_time = hour * 60 + minute,
  arr_time = (arr_time %/% 100) * 60 + (arr_time %% 100),
  airtime2 = arr_time - dep_time,
  dep_sched = dep_time + dep_delay
)

ggplot(flights, aes(dep_sched)) + geom_histogram(binwidth = 60)
ggplot(flights, aes(dep_sched %% 60)) + geom_histogram(binwidth = 1)
ggplot(flights, aes(air_time - airtime2)) + geom_histogram()
```

1.  Currently `dep_time` and `sched_dep_time` are convenient to look at, but
    hard to compute with because they're not really continuous numbers. 
    Convert them to a more convenient representation of number of minutes
    since midnight.
    
1.  Compare `air_time` with `arr_time - dep_time`. What do you expect to see?
    What do you see? What do you need to do to fix it?
    
1.  Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you
    expect those three numbers to be related?

1.  Find the 10 most delayed flights using a ranking function. How do you want 
    to handle ties? Carefully read the documentation for `min_rank()`.

1.  What does `1:3 + 1:10` return? Why?

1.  What trigonometric functions does R provide?









































