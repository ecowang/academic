---
title: r for data science 04 data transformation
author: 王强
date: '2017-10-09'
slug: r-for-data-science-04-data-transformation
categories:
  - R
tags:
  - Data  transformation
  - R
draft: yes
---

[本章](http://r4ds.had.co.nz/transform.html)讲数据变形。

## 简介

通过数据可视化能够发现很多隐含的信息，但一般很难拿到数据能直接进行可视化，由于数据格式不对，要经过整理和变形，按某个变量排序，重命名变量或者增加新变量等操作。这些操作说起来简单，放到excel里点一点鼠标都有了，结合数据透视表也能实现这些目的。之所以要在R里也做这些，可以类比一下，美国已经有GPS系统了，我们为什么拼了命的还要搞北斗呢？不是一个系统，操作起来不顺手嘛。作为一个语言，应该能完成体系性的操作。这些操作原来在R的基础语句中，可以通过aply系列完成，但这个系列语句意思晦涩比较难以掌握，Hadley写了`dplyr`包以后,基本此类操作都是用他的函数。

### 5.1.1 预要求

本章主要介绍`dplyr`包的用法，次包是`tidyverse`系列包的一个重要组成，`tidyverse`是Hadley组织的一个系列包，里面主要包含他写的，也有几个其他的关于数据处理统计作图的包。这年头，大家都在建立生态圈，这个小小的统计领域也不例外，R通过开源聚集了一大批拥趸，而里面也有不同的流派和领域，`tidyverse`就是一个重要的，优质的流派。记得有一次Hadely讲座时候有人问他，这些包的功能能否纳入到R的基本功能里，他神秘的笑着，说，这不大可能。可能是我想多了，当时觉得，R的江湖也是波诡云谲啊，先到咸阳为王上，后来者哪怕再优秀，也要经过不断的斗争，形成气候才有可能受到招安。

回到`dplyr`包，练习数据使用`nycflights13`包，使用`ggplot2`来做图，帮助我们理解所完成的变形，和变形的目的。

```{r}
library(nycflights13)
library(tidyverse)
```

注意！载入`didyverse`以后，会有提示信息，说哪些函数把base R里的函数给覆盖了，基础包`stats`里有几个函数名和和本包里面重名，如`filter`和`lag`，如果还想要用基础包里的这俩函数，需要用`stats::filter()`和`stats::lag()`。当然一般用不着，因为，这几个函数比基础包里的好用太多了。

### 5.1.2 nycflights13

nycflights13包里面的flights，收集了纽约2013年336776架飞机的起飞降落飞行时间等信息。打出来看看是这样的。

```{r}
flights
```

如果之前接触过R，可以发现这个数据有点不一样，看着像数据框data frame，但上面写着个`tibble`。tibble是Hadley创造的一种数据格式，和数据框类似，但更加灵活，里面不但可以再套数据框，还可以套模型，几乎啥都能套进去。后面会有建模的问题，使用这个格式，能更方便地建模，后面会有更多了解。

数据的介绍里，仅对前面几列做了说明，如果要都看得用`View(flights)`。说明中有列的名称，和数据类型，数据类型包括以下这些。

* `int` stands for integers. 整数。

* `dbl` stands for doubles, or real numbers.实数，浮点。

* `chr` stands for character vectors, or strings.字符。

* `dttm` stands for date-times (a date + a time).日期+时间。

还有几种会遇到数据类型：

* `lgl` stands for logical, vectors that contain only `TRUE` or `FALSE`.逻辑变量。 

* `fctr` stands for factors, which R uses to represent categorical variables
  with fixed possible values.因子，即具有固定值得分类变量。

* `date` stands for dates.日期。

### dplyr 基础

主要学5个函数，包括：

* 按数值选择变量 (`filter()`)。比如我有一批树高的测量值，想只分析1999-2011年栽植的，就可以用这个函数进行筛选，函数名也很只管，filter，就是要按要求filter特定的行，相当于excel里，先按一列排序，然后再选择范围内的行。

* 排序 (`arrange()`)。类比excel，按某一列进行排序，可以正着排也可以倒着排。

* 按其名称选择变量 (`select()`)。

*  (`mutate()`)。这个太有用了，基于已有的变量，用函数产生新变量。

* 汇总统计值 (`summarise()`)。

重要的！以上函数都可以和一个伟大的函数合作使用——`group_by()`。这个函数能够进行不同的分组，然后让上面那些函数充分发挥作用。这非常5+1个函数弄熟了，数据基础操作就差不多了。

这些函数使用方式都很相似：

1.  第一个参数是要操作的数，一般以数据框的结构输入，可以是dataframe，最好是tibble。

1.  接下来是数据框的变量名，是函数具体要搞的对象。
    
1.  产出的结果都是数据框。

## 用 `filter()`，选择感兴趣的子数据框。

顾名思义，filter，就是用来筛选的，筛选出来形成一个新的数据框。如针对飞机数据，想选择1月1日起飞降落的飞机数据，可以这样写：

```{r}
filter(flights, month == 1, day == 1)
```

注意这里产生了新的数据框，但没有赋给任何一个对象，如要保存，需要自己定义赋值。可以用= 也可以用箭头。

```{r}
jan1 <- filter(flights, month == 1, day == 1) 
# 这个箭头的方向和等号相同。
```

如果我们想既赋值，又在控制器里显示出来，可以这样写，把语句放在括号里就行了：

```{r}
(dec25 <- filter(flights, month == 12, day == 25))
```

### 几个比较符号

要使用filter，肯定要界定条件，需要这几个比较符号：`>`, `>=`, `<`, `<=`, `!=` (不等于), and `==` (等于)。

注意， `=`，和`==`的区别。前一个是赋值，后一个才是等于，弄错了可能会有错误信息提示。

```{r, error = TRUE}
filter(flights, month = 1)
```

注意2，当涉及浮点数的时候，计算机算不准。看看开方以后再乘方，或者除不尽的再乘回去的结果：

```{r}
sqrt(2) ^ 2 == 2
1/49 * 49 == 1
```

因为这种情况下计算机存储的数，都是**近似值**！所以这种情况下，不要用`==`，要用`near()`。

```{r}
near(sqrt(2) ^ 2,  2)
near(1 / 49 * 49, 1)
```

### 逻辑符号（布林运算符）

数据集里各变量之互有关系，有时候要用逻辑符号进行精准选择。 如`&`是"和", `|` 是 "或", ， `!` 是 "非"。见下图：

![两个变量间的逻辑运算符](http://r4ds.had.co.nz/diagrams/transform-logical.png)


如选择11、12月的飞机：

```{r, eval = FALSE}
filter(flights, month == 11 | month == 12)
```

作者还提供了一种方式，是使用 `x %in% y`， 这会把所有y里有的x所在的行挑出来。下面代码和上面作用相同。

```{r, eval = FALSE}
nov_dec <- filter(flights, month %in% c(11, 12))
```


有时可以用De Morgan法则来记忆： `!(x & y)` 等价于 `!x | !y`,还有 `!(x | y)`等价于 `!x & !y`。

除了 `&` 和 `|`, R 还有 `&&` 和 `||`。这里还不会涉及，到[conditional execution]会有介绍。

### 缺失值

在R里面，缺失值很让人头疼，当然在其他体系里面也各有毛病，毕竟缺了，怎么处理都麻烦。 `NA`的意思是 ("not availables")，excel里的空白，读取到r里面就是NA。excel里也是凑合着把空白当成0。而在R里面，NA有传染性，涉及到的结果很多都会变成NA。

```{r}
NA > 5
10 == NA
NA + 10
NA / 2
```

更奇葩的结果是这个：

```{r}
NA == NA
```

如果想要知道一个值是否缺失，使用`is.na()`。

`filter()` 默认忽略 `FALSE` 和 `NA` 值，如果想要表现缺失值，要在函数中自行明确。

```{r}
df <- tibble(x = c(1, NA, 3))
filter(df, x > 1)
filter(df, is.na(x) | x > 1)
```

### 练习作业

1.  找到如下条件的飞机

    1. 晚点2小时及以上。
    
    ```{r}
filter(flights, arr_delay>=120)
    ```
    
    
    2. 飞往 Houston (`IAH` or `HOU`)
    
    ```{r}
filter(flights, dest=="IAH" | dest =="HOU")

filter(flights, dest %in% c("IAH", "HOU"))
```
    
    
    3. 由 United, American, 或 Delta运营
    
    ```{r}
airlines # 看缩写代表谁
filter(flights, carrier %in% c("UA", "AA", "DL"))
```
    
    
    4. 筛选7——9月的飞机班次
    
    ```{r}
filter(flights, month %in% c(7,8,9))
```
    
    
    5. Arrived more than two hours late, but didn't leave late
    
    ```{r}
filter(flights, arr_delay > 120 & dep_delay <= 0)
```
    
    6. Were delayed by at least an hour, but made up over 30 minutes in flight
    
    ```{r}
filter(flights, dep_delay >= 60 & (dep_delay - arr_delay) >= 30 )
```
    
    
    7. Departed between midnight and 6am (inclusive)
    
    ```{r}
filter(flights, dep_time >= 2400 | dep_time <= 600)

# 开始觉得应该从time_hour里提取控制值，不过搜了下两三个人都是这么写的，先这么滴吧。
```
    

1.  Another useful dplyr filtering helper is `between()`. What does it do?
    Can you use it to simplify the code needed to answer the previous 
    challenges?
    
    between(x, left, right) 在左右之间（含），比如可以
    
    ```{r}
filter(flights, between(arr_delay, 30, 60))
```
    

1.  How many flights have a missing `dep_time`? What other variables are 
    missing? What might these rows represent?
    
    ```{r}
sum(is.na(flights$dep_time))

map_dbl(flights, ~ sum(is.na(.x)))
```
    

1.  Why is `NA ^ 0` not missing? Why is `NA | TRUE` not missing?
    Why is `FALSE & NA` not missing? Can you figure out the general
    rule?  (`NA * 0` is a tricky counterexample!)
    
    

























