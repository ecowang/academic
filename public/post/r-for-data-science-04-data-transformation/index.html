<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.27.1" />
  <meta name="author" content="王强">
  

  
  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="/css/highlight.min.css">
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  


  

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto&#43;Mono">
  
  <link rel="stylesheet" href="/styles.css">
  

  

  <link rel="alternate" href="" type="application/rss+xml" title="生态网">
  <link rel="feed" href="" type="application/rss+xml" title="生态网">

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="/post/r-for-data-science-04-data-transformation/">

  

  <title>r for data science 04 data transformation | 生态网</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">生态网</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#posts">
            
            <span>Posts</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#contact">
            
            <span>Contact</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <h1 itemprop="name">r for data science 04 data transformation</h1>
    

<div class="article-metadata">

  <span class="article-date">
    
    <time datetime="2017-10-09 00:00:00 &#43;0000 UTC" itemprop="datePublished">
      2017-10-09
    </time>
  </span>

  
  <span class="article-reading-time">
    46 min read
  </span>
  

  
  
  
  <span class="article-categories">
    <i class="fa fa-folder"></i>
    
    <a href="/categories/r">R</a
    >
    
  </span>
  
  

  
  
  
  <span class="article-tags">
    <i class="fa fa-tags"></i>
    
    <a href="/tags/data--transformation">Data  transformation</a
    >, 
    
    <a href="/tags/r">R</a
    >
    
  </span>
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=r%20for%20data%20science%2004%20data%20transformation&amp;url=%2fpost%2fr-for-data-science-04-data-transformation%2f"
         target="_blank">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=%2fpost%2fr-for-data-science-04-data-transformation%2f"
         target="_blank">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fpost%2fr-for-data-science-04-data-transformation%2f&amp;title=r%20for%20data%20science%2004%20data%20transformation"
         target="_blank">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=%2fpost%2fr-for-data-science-04-data-transformation%2f&amp;title=r%20for%20data%20science%2004%20data%20transformation"
         target="_blank">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=r%20for%20data%20science%2004%20data%20transformation&amp;body=%2fpost%2fr-for-data-science-04-data-transformation%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>

    <div class="article-style" itemprop="articleBody">
      <p><a href="http://r4ds.had.co.nz/transform.html">本章</a>讲数据变形。</p>
<div class="section level2">
<h2>简介</h2>
<p>通过数据可视化能够发现很多隐含的信息，但一般很难拿到数据能直接进行可视化，由于数据格式不对，要经过整理和变形，按某个变量排序，重命名变量或者增加新变量等操作。这些操作说起来简单，放到excel里点一点鼠标都有了，结合数据透视表也能实现这些目的。之所以要在R里也做这些，可以类比一下，美国已经有GPS系统了，我们为什么拼了命的还要搞北斗呢？不是一个系统，操作起来不顺手嘛。作为一个语言，应该能完成体系性的操作。这些操作原来在R的基础语句中，可以通过aply系列完成，但这个系列语句意思晦涩比较难以掌握，Hadley写了<code>dplyr</code>包以后,基本此类操作都是用他的函数。</p>
<div class="section level3">
<h3>5.1.1 预要求</h3>
<p>本章主要介绍<code>dplyr</code>包的用法，次包是<code>tidyverse</code>系列包的一个重要组成，<code>tidyverse</code>是Hadley组织的一个系列包，里面主要包含他写的，也有几个其他的关于数据处理统计作图的包。这年头，大家都在建立生态圈，这个小小的统计领域也不例外，R通过开源聚集了一大批拥趸，而里面也有不同的流派和领域，<code>tidyverse</code>就是一个重要的，优质的流派。记得有一次Hadely讲座时候有人问他，这些包的功能能否纳入到R的基本功能里，他神秘的笑着，说，这不大可能。可能是我想多了，当时觉得，R的江湖也是波诡云谲啊，先到咸阳为王上，后来者哪怕再优秀，也要经过不断的斗争，形成气候才有可能受到招安。</p>
<p>回到<code>dplyr</code>包，练习数据使用<code>nycflights13</code>包，使用<code>ggplot2</code>来做图，帮助我们理解所完成的变形，和变形的目的。</p>
<pre class="r"><code>library(nycflights13)
library(tidyverse)</code></pre>
<pre><code>## Loading tidyverse: ggplot2
## Loading tidyverse: tibble
## Loading tidyverse: tidyr
## Loading tidyverse: readr
## Loading tidyverse: purrr
## Loading tidyverse: dplyr</code></pre>
<pre><code>## Conflicts with tidy packages ----------------------------------------------</code></pre>
<pre><code>## filter(): dplyr, stats
## lag():    dplyr, stats</code></pre>
<p>注意！载入<code>didyverse</code>以后，会有提示信息，说哪些函数把base R里的函数给覆盖了，基础包<code>stats</code>里有几个函数名和和本包里面重名，如<code>filter</code>和<code>lag</code>，如果还想要用基础包里的这俩函数，需要用<code>stats::filter()</code>和<code>stats::lag()</code>。当然一般用不着，因为，这几个函数比基础包里的好用太多了。</p>
</div>
<div id="nycflights13" class="section level3">
<h3>5.1.2 nycflights13</h3>
<p>nycflights13包里面的flights，收集了纽约2013年336776架飞机的起飞降落飞行时间等信息。打出来看看是这样的。</p>
<pre class="r"><code>flights</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>如果之前接触过R，可以发现这个数据有点不一样，看着像数据框data frame，但上面写着个<code>tibble</code>。tibble是Hadley创造的一种数据格式，和数据框类似，但更加灵活，里面不但可以再套数据框，还可以套模型，几乎啥都能套进去。后面会有建模的问题，使用这个格式，能更方便地建模，后面会有更多了解。</p>
<p>数据的介绍里，仅对前面几列做了说明，如果要都看得用<code>View(flights)</code>。说明中有列的名称，和数据类型，数据类型包括以下这些。</p>
<ul>
<li><p><code>int</code> stands for integers. 整数。</p></li>
<li><p><code>dbl</code> stands for doubles, or real numbers.实数，浮点。</p></li>
<li><p><code>chr</code> stands for character vectors, or strings.字符。</p></li>
<li><p><code>dttm</code> stands for date-times (a date + a time).日期+时间。</p></li>
</ul>
<p>还有几种会遇到数据类型：</p>
<ul>
<li><p><code>lgl</code> stands for logical, vectors that contain only <code>TRUE</code> or <code>FALSE</code>.逻辑变量。</p></li>
<li><p><code>fctr</code> stands for factors, which R uses to represent categorical variables with fixed possible values.因子，即具有固定值得分类变量。</p></li>
<li><p><code>date</code> stands for dates.日期。</p></li>
</ul>
</div>
<div id="dplyr-" class="section level3">
<h3>dplyr 基础</h3>
<p>主要学5个函数，包括：</p>
<ul>
<li><p>按数值选择变量 (<code>filter()</code>)。比如我有一批树高的测量值，想只分析1999-2011年栽植的，就可以用这个函数进行筛选，函数名也很只管，filter，就是要按要求filter特定的行，相当于excel里，先按一列排序，然后再选择范围内的行。</p></li>
<li><p>排序 (<code>arrange()</code>)。类比excel，按某一列进行排序，可以正着排也可以倒着排。</p></li>
<li><p>按其名称选择变量 (<code>select()</code>)。</p></li>
<li><p>(<code>mutate()</code>)。这个太有用了，基于已有的变量，用函数产生新变量。</p></li>
<li><p>汇总统计值 (<code>summarise()</code>)。</p></li>
</ul>
<p>重要的！以上函数都可以和一个伟大的函数合作使用——<code>group_by()</code>。这个函数能够进行不同的分组，然后让上面那些函数充分发挥作用。这非常5+1个函数弄熟了，数据基础操作就差不多了。</p>
<p>这些函数使用方式都很相似：</p>
<ol style="list-style-type: decimal">
<li><p>第一个参数是要操作的数，一般以数据框的结构输入，可以是dataframe，最好是tibble。</p></li>
<li><p>接下来是数据框的变量名，是函数具体要搞的对象。</p></li>
<li><p>产出的结果都是数据框。</p></li>
</ol>
</div>
</div>
<div id="-filter" class="section level2">
<h2>用 <code>filter()</code>，选择感兴趣的子数据框。</h2>
<p>顾名思义，filter，就是用来筛选的，筛选出来形成一个新的数据框。如针对飞机数据，想选择1月1日起飞降落的飞机数据，可以这样写：</p>
<pre class="r"><code>filter(flights, month == 1, day == 1)</code></pre>
<pre><code>## # A tibble: 842 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ... with 832 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>注意这里产生了新的数据框，但没有赋给任何一个对象，如要保存，需要自己定义赋值。可以用= 也可以用箭头。</p>
<pre class="r"><code>jan1 &lt;- filter(flights, month == 1, day == 1) 
# 这个箭头的方向和等号相同。</code></pre>
<p>如果我们想既赋值，又在控制器里显示出来，可以这样写，把语句放在括号里就行了：</p>
<pre class="r"><code>(dec25 &lt;- filter(flights, month == 12, day == 25))</code></pre>
<pre><code>## # A tibble: 719 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013    12    25      456            500        -4      649
##  2  2013    12    25      524            515         9      805
##  3  2013    12    25      542            540         2      832
##  4  2013    12    25      546            550        -4     1022
##  5  2013    12    25      556            600        -4      730
##  6  2013    12    25      557            600        -3      743
##  7  2013    12    25      557            600        -3      818
##  8  2013    12    25      559            600        -1      855
##  9  2013    12    25      559            600        -1      849
## 10  2013    12    25      600            600         0      850
## # ... with 709 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<div class="section level3">
<h3>几个比较符号</h3>
<p>要使用filter，肯定要界定条件，需要这几个比较符号：<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code> (不等于), and <code>==</code> (等于)。</p>
<p>注意， <code>=</code>，和<code>==</code>的区别。前一个是赋值，后一个才是等于，弄错了可能会有错误信息提示。</p>
<pre class="r"><code>filter(flights, month = 1)</code></pre>
<pre><code>## Error: `month` (`month = 1`) must not be named, do you need `==`?</code></pre>
<p>注意2，当涉及浮点数的时候，计算机算不准。看看开方以后再乘方，或者除不尽的再乘回去的结果：</p>
<pre class="r"><code>sqrt(2) ^ 2 == 2</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>1/49 * 49 == 1</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>因为这种情况下计算机存储的数，都是<strong>近似值</strong>！所以这种情况下，不要用<code>==</code>，要用<code>near()</code>。</p>
<pre class="r"><code>near(sqrt(2) ^ 2,  2)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>near(1 / 49 * 49, 1)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div class="section level3">
<h3>逻辑符号（布林运算符）</h3>
<p>数据集里各变量之互有关系，有时候要用逻辑符号进行精准选择。 如<code>&amp;</code>是“和”, <code>|</code> 是 “或”, ， <code>!</code> 是 “非”。见下图：</p>
<div class="figure">
<img src="http://r4ds.had.co.nz/diagrams/transform-logical.png" alt="两个变量间的逻辑运算符" />
<p class="caption">两个变量间的逻辑运算符</p>
</div>
<p>如选择11、12月的飞机：</p>
<pre class="r"><code>filter(flights, month == 11 | month == 12)</code></pre>
<p>作者还提供了一种方式，是使用 <code>x %in% y</code>， 这会把所有y里有的x所在的行挑出来。下面代码和上面作用相同。</p>
<pre class="r"><code>nov_dec &lt;- filter(flights, month %in% c(11, 12))</code></pre>
<p>有时可以用De Morgan法则来记忆： <code>!(x &amp; y)</code> 等价于 <code>!x | !y</code>,还有 <code>!(x | y)</code>等价于 <code>!x &amp; !y</code>。</p>
<p>除了 <code>&amp;</code> 和 <code>|</code>, R 还有 <code>&amp;&amp;</code> 和 <code>||</code>。这里还不会涉及，到[conditional execution]会有介绍。</p>
</div>
<div class="section level3">
<h3>缺失值</h3>
<p>在R里面，缺失值很让人头疼，当然在其他体系里面也各有毛病，毕竟缺了，怎么处理都麻烦。 <code>NA</code>的意思是 (“not availables”)，excel里的空白，读取到r里面就是NA。excel里也是凑合着把空白当成0。而在R里面，NA有传染性，涉及到的结果很多都会变成NA。</p>
<pre class="r"><code>NA &gt; 5</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>10 == NA</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>NA + 10</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>NA / 2</code></pre>
<pre><code>## [1] NA</code></pre>
<p>更奇葩的结果是这个：</p>
<pre class="r"><code>NA == NA</code></pre>
<pre><code>## [1] NA</code></pre>
<p>如果想要知道一个值是否缺失，使用<code>is.na()</code>。</p>
<p><code>filter()</code> 默认忽略 <code>FALSE</code> 和 <code>NA</code> 值，如果想要表现缺失值，要在函数中自行明确。</p>
<pre class="r"><code>df &lt;- tibble(x = c(1, NA, 3))
filter(df, x &gt; 1)</code></pre>
<pre><code>## # A tibble: 1 x 1
##       x
##   &lt;dbl&gt;
## 1     3</code></pre>
<pre class="r"><code>filter(df, is.na(x) | x &gt; 1)</code></pre>
<pre><code>## # A tibble: 2 x 1
##       x
##   &lt;dbl&gt;
## 1    NA
## 2     3</code></pre>
</div>
<div class="section level3">
<h3>练习作业</h3>
<ol style="list-style-type: decimal">
<li><p>找到如下条件的飞机</p>
<ol style="list-style-type: decimal">
<li>晚点2小时及以上。</li>
</ol>
<pre class="r"><code>filter(flights, arr_delay&gt;=120)</code></pre>
<pre><code>## # A tibble: 10,200 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      811            630       101     1047
##  2  2013     1     1      848           1835       853     1001
##  3  2013     1     1      957            733       144     1056
##  4  2013     1     1     1114            900       134     1447
##  5  2013     1     1     1505           1310       115     1638
##  6  2013     1     1     1525           1340       105     1831
##  7  2013     1     1     1549           1445        64     1912
##  8  2013     1     1     1558           1359       119     1718
##  9  2013     1     1     1732           1630        62     2028
## 10  2013     1     1     1803           1620       103     2008
## # ... with 10,190 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>飞往 Houston (<code>IAH</code> or <code>HOU</code>)</li>
</ol>
<pre class="r"><code>filter(flights, dest==&quot;IAH&quot; | dest ==&quot;HOU&quot;)</code></pre>
<pre><code>## # A tibble: 9,313 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      623            627        -4      933
##  4  2013     1     1      728            732        -4     1041
##  5  2013     1     1      739            739         0     1104
##  6  2013     1     1      908            908         0     1228
##  7  2013     1     1     1028           1026         2     1350
##  8  2013     1     1     1044           1045        -1     1352
##  9  2013     1     1     1114            900       134     1447
## 10  2013     1     1     1205           1200         5     1503
## # ... with 9,303 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code>filter(flights, dest %in% c(&quot;IAH&quot;, &quot;HOU&quot;))</code></pre>
<pre><code>## # A tibble: 9,313 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      623            627        -4      933
##  4  2013     1     1      728            732        -4     1041
##  5  2013     1     1      739            739         0     1104
##  6  2013     1     1      908            908         0     1228
##  7  2013     1     1     1028           1026         2     1350
##  8  2013     1     1     1044           1045        -1     1352
##  9  2013     1     1     1114            900       134     1447
## 10  2013     1     1     1205           1200         5     1503
## # ... with 9,303 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>由 United, American, 或 Delta运营</li>
</ol>
<pre class="r"><code>airlines # 看缩写代表谁</code></pre>
<pre><code>## # A tibble: 16 x 2
##    carrier                        name
##      &lt;chr&gt;                       &lt;chr&gt;
##  1      9E           Endeavor Air Inc.
##  2      AA      American Airlines Inc.
##  3      AS        Alaska Airlines Inc.
##  4      B6             JetBlue Airways
##  5      DL        Delta Air Lines Inc.
##  6      EV    ExpressJet Airlines Inc.
##  7      F9      Frontier Airlines Inc.
##  8      FL AirTran Airways Corporation
##  9      HA      Hawaiian Airlines Inc.
## 10      MQ                   Envoy Air
## 11      OO       SkyWest Airlines Inc.
## 12      UA       United Air Lines Inc.
## 13      US             US Airways Inc.
## 14      VX              Virgin America
## 15      WN      Southwest Airlines Co.
## 16      YV          Mesa Airlines Inc.</code></pre>
<pre class="r"><code>filter(flights, carrier %in% c(&quot;UA&quot;, &quot;AA&quot;, &quot;DL&quot;))</code></pre>
<pre><code>## # A tibble: 139,504 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      554            600        -6      812
##  5  2013     1     1      554            558        -4      740
##  6  2013     1     1      558            600        -2      753
##  7  2013     1     1      558            600        -2      924
##  8  2013     1     1      558            600        -2      923
##  9  2013     1     1      559            600        -1      941
## 10  2013     1     1      559            600        -1      854
## # ... with 139,494 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>筛选7——9月的飞机班次。</li>
</ol>
<pre class="r"><code>filter(flights, month %in% c(7,8,9))</code></pre>
<pre><code>## # A tibble: 86,326 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     7     1        1           2029       212      236
##  2  2013     7     1        2           2359         3      344
##  3  2013     7     1       29           2245       104      151
##  4  2013     7     1       43           2130       193      322
##  5  2013     7     1       44           2150       174      300
##  6  2013     7     1       46           2051       235      304
##  7  2013     7     1       48           2001       287      308
##  8  2013     7     1       58           2155       183      335
##  9  2013     7     1      100           2146       194      327
## 10  2013     7     1      100           2245       135      337
## # ... with 86,316 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<ol start="5" style="list-style-type: decimal">
<li>起飞没有晚点，但到港晚点两小时以上。</li>
</ol>
<pre class="r"><code>filter(flights, arr_delay &gt; 120 &amp; dep_delay &lt;= 0)</code></pre>
<pre><code>## # A tibble: 29 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1    27     1419           1420        -1     1754
##  2  2013    10     7     1350           1350         0     1736
##  3  2013    10     7     1357           1359        -2     1858
##  4  2013    10    16      657            700        -3     1258
##  5  2013    11     1      658            700        -2     1329
##  6  2013     3    18     1844           1847        -3       39
##  7  2013     4    17     1635           1640        -5     2049
##  8  2013     4    18      558            600        -2     1149
##  9  2013     4    18      655            700        -5     1213
## 10  2013     5    22     1827           1830        -3     2217
## # ... with 19 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<ol start="6" style="list-style-type: decimal">
<li>起飞晚点一小时以上，但飞起来找补回来至少半小时。</li>
</ol>
<pre class="r"><code>filter(flights, dep_delay &gt;= 60 &amp; (dep_delay - arr_delay) &gt;= 30 )</code></pre>
<pre><code>## # A tibble: 2,074 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1     1716           1545        91     2140
##  2  2013     1     1     2205           1720       285       46
##  3  2013     1     1     2326           2130       116      131
##  4  2013     1     3     1503           1221       162     1803
##  5  2013     1     3     1821           1530       171     2131
##  6  2013     1     3     1839           1700        99     2056
##  7  2013     1     3     1850           1745        65     2148
##  8  2013     1     3     1923           1815        68     2036
##  9  2013     1     3     1941           1759       102     2246
## 10  2013     1     3     1950           1845        65     2228
## # ... with 2,064 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<ol start="7" style="list-style-type: decimal">
<li>凌晨到早上六点之间（含两头）起飞的飞机。</li>
</ol>
<pre class="r"><code>filter(flights, dep_time &gt;= 2400 | dep_time &lt;= 600)</code></pre>
<pre><code>## # A tibble: 9,373 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ... with 9,363 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code># 开始觉得应该从time_hour里提取控制值，不过搜了下两三个人都是这么写的，先这么滴吧。</code></pre></li>
<li><p>另一个和filter配合比较好的函数是 <code>between()</code>。它怎么用？你能否用它解决上面的问题吗？</p>
<p>between(x, left, right) 在左右之间（含），比如可以</p>
<pre class="r"><code>filter(flights, between(arr_delay, 30, 60))</code></pre>
<pre><code>## # A tibble: 25,013 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      542            540         2      923
##  2  2013     1     1      559            600        -1      941
##  3  2013     1     1      608            600         8      807
##  4  2013     1     1      635            635         0     1028
##  5  2013     1     1      702            700         2     1058
##  6  2013     1     1      724            730        -6     1111
##  7  2013     1     1      732            645        47     1011
##  8  2013     1     1      749            710        39      939
##  9  2013     1     1      754            755        -1     1103
## 10  2013     1     1      826            715        71     1136
## # ... with 25,003 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre></li>
<li><p>数据里的 <code>dep_time</code>有多少缺失值？其他变量呢？这些含有缺失值的行如何表现？</p>
<pre class="r"><code>sum(is.na(flights$dep_time))</code></pre>
<pre><code>## [1] 8255</code></pre>
<pre class="r"><code>map_dbl(flights, ~ sum(is.na(.x)))</code></pre>
<pre><code>##           year          month            day       dep_time sched_dep_time 
##              0              0              0           8255              0 
##      dep_delay       arr_time sched_arr_time      arr_delay        carrier 
##           8255           8713              0           9430              0 
##         flight        tailnum         origin           dest       air_time 
##              0           2512              0              0           9430 
##       distance           hour         minute      time_hour 
##              0              0              0              0</code></pre></li>
<li><p>为什么 <code>NA ^ 0</code> 不是缺失值？为什么 <code>NA | TRUE</code> 不是缺失值？为什么 <code>FALSE &amp; NA</code> 不是缺失值？你能发现规律吗？(<code>NA * 0</code> 是个有趣的例子)</p>
<p><code>NA ^ 0</code>是1，因为任何值得0次方都是1。 <code>NA | TRUE</code>用<code>或|</code>连接，返回<code>TURE</code>，<code>FALSE &amp; NA</code>用<code>且&amp;</code>连接，则为FALSE。总结个规律，就是范围的大小关系的规律，FALSE最惨，一错啥都没有，NA好歹算个缺失值，TURE是相对最牛，所以这FALSE 和 NA 放一块按照比惨关系，TURE最牛。</p></li>
</ol>
</div>
</div>
<div id="-arrange" class="section level2">
<h2>用 <code>arrange()</code>对行排序</h2>
<p><code>arrange()</code> 和 <code>filter()</code> 使用方式相似，只不过功能不是筛选而是是排序。它用一列或多列进行排序，也可以用基于列的更复杂的计算式来排序。如果是用多列来排序，则按照优先级进行排列。</p>
<pre class="r"><code>arrange(flights, year, month, day)</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code>#按照年、月、日进行排列，正序从小到大。</code></pre>
<p>如果要倒序排列， 则用 <code>desc()</code> :</p>
<pre class="r"><code>arrange(flights, desc(arr_delay))</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     9      641            900      1301     1242
##  2  2013     6    15     1432           1935      1137     1607
##  3  2013     1    10     1121           1635      1126     1239
##  4  2013     9    20     1139           1845      1014     1457
##  5  2013     7    22      845           1600      1005     1044
##  6  2013     4    10     1100           1900       960     1342
##  7  2013     3    17     2321            810       911      135
##  8  2013     7    22     2257            759       898      121
##  9  2013    12     5      756           1700       896     1058
## 10  2013     5     3     1133           2055       878     1250
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>缺失值总是放在最后。</p>
<pre class="r"><code>df &lt;- tibble(x = c(5, 2, NA))
arrange(df, x)</code></pre>
<pre><code>## # A tibble: 3 x 1
##       x
##   &lt;dbl&gt;
## 1     2
## 2     5
## 3    NA</code></pre>
<pre class="r"><code>arrange(df, desc(x))</code></pre>
<pre><code>## # A tibble: 3 x 1
##       x
##   &lt;dbl&gt;
## 1     5
## 2     2
## 3    NA</code></pre>
<div id="exercises" class="section level3">
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>用 <code>arrange()</code> 把缺失值排在前面。提示，用 <code>is.na()</code>。</p>
<pre class="r"><code>df &lt;- tibble(x = c(5, 2, NA))
arrange(df, desc(is.na(x)), x)</code></pre>
<pre><code>## # A tibble: 3 x 1
##       x
##   &lt;dbl&gt;
## 1    NA
## 2     2
## 3     5</code></pre>
<pre class="r"><code># 用is.na() 先按得到的Ture和False排起来，然后再按照x排。</code></pre></li>
<li><p>对 <code>flights</code>，找到晚点最多的飞机，找到起飞最早的飞机。</p>
<pre class="r"><code>arrange(flights, desc(arr_delay))</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     9      641            900      1301     1242
##  2  2013     6    15     1432           1935      1137     1607
##  3  2013     1    10     1121           1635      1126     1239
##  4  2013     9    20     1139           1845      1014     1457
##  5  2013     7    22      845           1600      1005     1044
##  6  2013     4    10     1100           1900       960     1342
##  7  2013     3    17     2321            810       911      135
##  8  2013     7    22     2257            759       898      121
##  9  2013    12     5      756           1700       896     1058
## 10  2013     5     3     1133           2055       878     1250
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code>arrange(flights, dep_delay) </code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013    12     7     2040           2123       -43       40
##  2  2013     2     3     2022           2055       -33     2240
##  3  2013    11    10     1408           1440       -32     1549
##  4  2013     1    11     1900           1930       -30     2233
##  5  2013     1    29     1703           1730       -27     1947
##  6  2013     8     9      729            755       -26     1002
##  7  2013    10    23     1907           1932       -25     2143
##  8  2013     3    30     2030           2055       -25     2213
##  9  2013     3     2     1431           1455       -24     1601
## 10  2013     5     5      934            958       -24     1225
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code># 这里是比计划早。</code></pre></li>
<li><p>Sort <code>flights</code> to find the fastest flights.</p>
<pre class="r"><code>arrange(flights, desc(distance/air_time))</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     5    25     1709           1700         9     1923
##  2  2013     7     2     1558           1513        45     1745
##  3  2013     5    13     2040           2025        15     2225
##  4  2013     3    23     1914           1910         4     2045
##  5  2013     1    12     1559           1600        -1     1849
##  6  2013    11    17      650            655        -5     1059
##  7  2013     2    21     2355           2358        -3      412
##  8  2013    11    17      759            800        -1     1212
##  9  2013    11    16     2003           1925        38       17
## 10  2013    11    16     2349           2359       -10      402
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code># 距离除以时间，从大到小。</code></pre></li>
<li><p>Which flights travelled the longest? Which travelled the shortest?</p>
<pre class="r"><code>arrange(flights, desc(distance))</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      857            900        -3     1516
##  2  2013     1     2      909            900         9     1525
##  3  2013     1     3      914            900        14     1504
##  4  2013     1     4      900            900         0     1516
##  5  2013     1     5      858            900        -2     1519
##  6  2013     1     6     1019            900        79     1558
##  7  2013     1     7     1042            900       102     1620
##  8  2013     1     8      901            900         1     1504
##  9  2013     1     9      641            900      1301     1242
## 10  2013     1    10      859            900        -1     1449
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code>arrange(flights, distance)</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     7    27       NA            106        NA       NA
##  2  2013     1     3     2127           2129        -2     2222
##  3  2013     1     4     1240           1200        40     1333
##  4  2013     1     4     1829           1615       134     1937
##  5  2013     1     4     2128           2129        -1     2218
##  6  2013     1     5     1155           1200        -5     1241
##  7  2013     1     6     2125           2129        -4     2224
##  8  2013     1     7     2124           2129        -5     2212
##  9  2013     1     8     2127           2130        -3     2304
## 10  2013     1     9     2126           2129        -3     2217
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre></li>
</ol>
</div>
</div>
<div id="-select" class="section level2">
<h2>用 <code>select()</code>选择列</h2>
<p>有时候我们会遇到很大的数据，有成百上千的变量，但只有少数是我们感兴趣的，这时候可以用<code>select()</code> 选择那些变量，方便地形成子数据集。这个过程是基于变量名进行的。</p>
<p><code>select()</code> 在飞机数据里没有什么用武之地，毕竟只有19个变量，在此仅作示意。</p>
<pre class="r"><code># 按变量名选择变量
select(flights, year, month, day)</code></pre>
<pre><code>## # A tibble: 336,776 x 3
##     year month   day
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1  2013     1     1
##  2  2013     1     1
##  3  2013     1     1
##  4  2013     1     1
##  5  2013     1     1
##  6  2013     1     1
##  7  2013     1     1
##  8  2013     1     1
##  9  2013     1     1
## 10  2013     1     1
## # ... with 336,766 more rows</code></pre>
<pre class="r"><code># 选择year和day变量之间的所有变量
select(flights, year:day)</code></pre>
<pre><code>## # A tibble: 336,776 x 3
##     year month   day
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1  2013     1     1
##  2  2013     1     1
##  3  2013     1     1
##  4  2013     1     1
##  5  2013     1     1
##  6  2013     1     1
##  7  2013     1     1
##  8  2013     1     1
##  9  2013     1     1
## 10  2013     1     1
## # ... with 336,766 more rows</code></pre>
<pre class="r"><code># 选择除了year和day之间数据的所有数据。
select(flights, -(year:day))</code></pre>
<pre><code>## # A tibble: 336,776 x 16
##    dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay
##       &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;
##  1      517            515         2      830            819        11
##  2      533            529         4      850            830        20
##  3      542            540         2      923            850        33
##  4      544            545        -1     1004           1022       -18
##  5      554            600        -6      812            837       -25
##  6      554            558        -4      740            728        12
##  7      555            600        -5      913            854        19
##  8      557            600        -3      709            723       -14
##  9      557            600        -3      838            846        -8
## 10      558            600        -2      753            745         8
## # ... with 336,766 more rows, and 10 more variables: carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>结合<code>select()</code>还有一些有用的函数。</p>
<ul>
<li><p><code>starts_with(&quot;abc&quot;)</code>: 匹配以 “abc”开头的变量名。</p></li>
<li><p><code>ends_with(&quot;xyz&quot;)</code>: 匹配以“xyz”结尾的变量名。</p></li>
<li><p><code>contains(&quot;ijk&quot;)</code>: 匹配含 “ijk” 的变量名。</p></li>
<li><p><code>matches(&quot;(.)\\1&quot;)</code>: 匹配含表达式的变量名，如这个是匹配所有含有重复字符的变量。在字符一节还有介绍。</p></li>
<li><p><code>num_range(&quot;x&quot;, 1:3)</code> 匹配 <code>x1</code>, <code>x2</code> 和 <code>x3</code>。</p></li>
</ul>
<p>更多用法参见select函数说明。</p>
<p>此外，<code>select()</code>也可用于重命名变量，但一般不太用，因为它只保留重命名的那几列。变量重命名用<code>rename()</code>，只重命名，不改变其他。</p>
<pre class="r"><code>select(flights, tail_num = tailnum)</code></pre>
<pre><code>## # A tibble: 336,776 x 1
##    tail_num
##       &lt;chr&gt;
##  1   N14228
##  2   N24211
##  3   N619AA
##  4   N804JB
##  5   N668DN
##  6   N39463
##  7   N516JB
##  8   N829AS
##  9   N593JB
## 10   N3ALAA
## # ... with 336,766 more rows</code></pre>
<pre class="r"><code>rename(flights, tail_num = tailnum)</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tail_num &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code># 新的在前面</code></pre>
<p>另一个可能常会用到的函数是 <code>everything()</code>，如果想把选择出来的列放前面，其他列也保留着，可以这样做。</p>
<pre class="r"><code>select(flights, time_hour, air_time, everything())</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##              time_hour air_time  year month   day dep_time sched_dep_time
##                 &lt;dttm&gt;    &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;
##  1 2013-01-01 05:00:00      227  2013     1     1      517            515
##  2 2013-01-01 05:00:00      227  2013     1     1      533            529
##  3 2013-01-01 05:00:00      160  2013     1     1      542            540
##  4 2013-01-01 05:00:00      183  2013     1     1      544            545
##  5 2013-01-01 06:00:00      116  2013     1     1      554            600
##  6 2013-01-01 05:00:00      150  2013     1     1      554            558
##  7 2013-01-01 06:00:00      158  2013     1     1      555            600
##  8 2013-01-01 06:00:00       53  2013     1     1      557            600
##  9 2013-01-01 06:00:00      140  2013     1     1      557            600
## 10 2013-01-01 06:00:00      138  2013     1     1      558            600
## # ... with 336,766 more rows, and 12 more variables: dep_delay &lt;dbl&gt;,
## #   arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;</code></pre>
<div class="section level3">
<h3>练习</h3>
<ol style="list-style-type: decimal">
<li><p>头脑风暴，想出尽可能多的选择 <code>dep_time</code>, <code>dep_delay</code>, <code>arr_time</code>,和 <code>arr_delay</code> 的方法。</p>
<pre class="r"><code>select(flights, dep_time,  dep_delay, arr_time, arr_delay)
select(flights, c(dep_time,  dep_delay, arr_time, arr_delay))
flights %&gt;% select(dep_time,  dep_delay, arr_time, arr_delay)

flights %&gt;% select(matches(&quot;^dep|^arr&quot;))</code></pre></li>
<li><p>在 <code>select()</code> 函数中，多次选择一个变量会怎么样？</p>
<pre class="r"><code>flights %&gt;% select(dep_delay, dep_delay, dep_delay)</code></pre>
<pre><code>## # A tibble: 336,776 x 1
##    dep_delay
##        &lt;dbl&gt;
##  1         2
##  2         4
##  3         2
##  4        -1
##  5        -6
##  6        -4
##  7        -5
##  8        -3
##  9        -3
## 10        -2
## # ... with 336,766 more rows</code></pre>
<pre class="r"><code># 和选一个效果一样。</code></pre></li>
<li><p>函数<code>one_of()</code> 的功能是什么？为什么对下面的文本向量的操作有用？</p>
<pre class="r"><code>vars &lt;- c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;dep_delay&quot;, &quot;arr_delay&quot;)</code></pre>
<p>这是<code>dplyr</code>包里的一个函数，属于<code>select_helpers</code>家族的一份子，顾名思义，任何一个在文本向量里有的变量，都能选择出来（variables in character vector.）。</p>
<pre class="r"><code>flights %&gt;% select(one_of(vars))</code></pre>
<pre><code>## # A tibble: 336,776 x 5
##     year month   day dep_delay arr_delay
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;
##  1  2013     1     1         2        11
##  2  2013     1     1         4        20
##  3  2013     1     1         2        33
##  4  2013     1     1        -1       -18
##  5  2013     1     1        -6       -25
##  6  2013     1     1        -4        12
##  7  2013     1     1        -5        19
##  8  2013     1     1        -3       -14
##  9  2013     1     1        -3        -8
## 10  2013     1     1        -2         8
## # ... with 336,766 more rows</code></pre>
<pre class="r"><code>select(flights, one_of(vars))</code></pre>
<pre><code>## # A tibble: 336,776 x 5
##     year month   day dep_delay arr_delay
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;
##  1  2013     1     1         2        11
##  2  2013     1     1         4        20
##  3  2013     1     1         2        33
##  4  2013     1     1        -1       -18
##  5  2013     1     1        -6       -25
##  6  2013     1     1        -4        12
##  7  2013     1     1        -5        19
##  8  2013     1     1        -3       -14
##  9  2013     1     1        -3        -8
## 10  2013     1     1        -2         8
## # ... with 336,766 more rows</code></pre></li>
<li><p>以下代码运行结果让你惊讶否？选择帮助默认如何处理这样的情况？你能如何改变默认设置？</p>
<pre class="r"><code>select(flights, contains(&quot;TIME&quot;))</code></pre>
<p>没有让我惊讶。可能作者想让我们认为这样会把变量名为“time”的变量选择出来，结果把所有里面含有”time“的都选出来。但contain意思本来就是含有，这样的结果很符合预期。如只想要time，则可以直接写，可以用match，也可以用one_of，当然用contain也可以，只需要把<code>contains(match, ignore.case = TRUE, vars = current_vars())</code>里面默认的ignore.case = TURE，改成FALSE就行了。此例中，没有这个变量：</p>
<pre class="r"><code>select(flights, contains(&quot;TIME&quot;, ignore.case = FALSE))</code></pre>
<pre><code>## # A tibble: 336,776 x 0</code></pre>
<pre class="r"><code># select(flights, &quot;TIME&quot;)

# 区别在于后面这个选不出来直接一个Error：Strings must match column names. Unknown columns: TIME。前面那样，产生一个多行0列的tibble。</code></pre></li>
</ol>
</div>
</div>
<div id="mutate" class="section level2">
<h2>使用<code>mutate()</code>函数，增加新变量</h2>
<p>除了使用已有变量对数据集进行选择，很多时候也需要通过原有变量建立新变量，然后再基于新变量进行选择，函数 <code>mutate()</code>就是负责干这个活。mutate，就是改变，突变的意思。</p>
<p><code>mutate()</code> 总是把新产生的变量放到数据集最后的列，飞机数据太宽，后面的列看不见，所以这里新做一个窄点的数据集。记住在Rstudio里面，查看全部数据最简单的方法就是使用<code>View()</code>另外注意，如果数据集太大，Rstudio在view后容易崩溃。</p>
<pre class="r"><code>flights_sml &lt;- select(flights, 
  year:day, 
  ends_with(&quot;delay&quot;), 
  distance, 
  air_time
)
mutate(flights_sml,
  gain = arr_delay - dep_delay,
  speed = distance / air_time * 60
)</code></pre>
<pre><code>## # A tibble: 336,776 x 9
##     year month   day dep_delay arr_delay distance air_time  gain    speed
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;
##  1  2013     1     1         2        11     1400      227     9 370.0441
##  2  2013     1     1         4        20     1416      227    16 374.2731
##  3  2013     1     1         2        33     1089      160    31 408.3750
##  4  2013     1     1        -1       -18     1576      183   -17 516.7213
##  5  2013     1     1        -6       -25      762      116   -19 394.1379
##  6  2013     1     1        -4        12      719      150    16 287.6000
##  7  2013     1     1        -5        19     1065      158    24 404.4304
##  8  2013     1     1        -3       -14      229       53   -11 259.2453
##  9  2013     1     1        -3        -8      944      140    -5 404.5714
## 10  2013     1     1        -2         8      733      138    10 318.6957
## # ... with 336,766 more rows</code></pre>
<p>注意刚刚新建的变量，后面也可以纳入计算，如下面，刚新建的gain，后面就用上了。</p>
<pre class="r"><code>mutate(flights_sml,
  gain = arr_delay - dep_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)</code></pre>
<pre><code>## # A tibble: 336,776 x 10
##     year month   day dep_delay arr_delay distance air_time  gain     hours
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;
##  1  2013     1     1         2        11     1400      227     9 3.7833333
##  2  2013     1     1         4        20     1416      227    16 3.7833333
##  3  2013     1     1         2        33     1089      160    31 2.6666667
##  4  2013     1     1        -1       -18     1576      183   -17 3.0500000
##  5  2013     1     1        -6       -25      762      116   -19 1.9333333
##  6  2013     1     1        -4        12      719      150    16 2.5000000
##  7  2013     1     1        -5        19     1065      158    24 2.6333333
##  8  2013     1     1        -3       -14      229       53   -11 0.8833333
##  9  2013     1     1        -3        -8      944      140    -5 2.3333333
## 10  2013     1     1        -2         8      733      138    10 2.3000000
## # ... with 336,766 more rows, and 1 more variables: gain_per_hour &lt;dbl&gt;</code></pre>
<p>如果只想保留新建变量，则使用 <code>transmute()</code>:</p>
<pre class="r"><code>transmute(flights,
  gain = arr_delay - dep_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)</code></pre>
<pre><code>## # A tibble: 336,776 x 3
##     gain     hours gain_per_hour
##    &lt;dbl&gt;     &lt;dbl&gt;         &lt;dbl&gt;
##  1     9 3.7833333      2.378855
##  2    16 3.7833333      4.229075
##  3    31 2.6666667     11.625000
##  4   -17 3.0500000     -5.573770
##  5   -19 1.9333333     -9.827586
##  6    16 2.5000000      6.400000
##  7    24 2.6333333      9.113924
##  8   -11 0.8833333    -12.452830
##  9    -5 2.3333333     -2.142857
## 10    10 2.3000000      4.347826
## # ... with 336,766 more rows</code></pre>
<div class="section level3">
<h3>常用新建变量的函数</h3>
<p>结合 <code>mutate()</code>，有很多新建变量的函数可以使用。注意能使用的函数都是向量式的（must be vectorised），即：输入的是向量（老变量），输出的还是向量（新变量）。想把能用的函数都列出来肯定不可能，在此仅对常用的一些做一概述：</p>
<ul>
<li><p>算术运算相关: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>。这些都有向量式操作的特点，另外使用运算符的时候会有循环法则，即当两个向量长度不一时，短的自动循环到和长的一样长度（想想在excel里复制粘帖时候的状态），这个特点在涉及单一数字（也是个长度为一的向量）时很好用 ，如<code>air_time / 60</code>, <code>hours * 60 + minute</code>，等。</p>
<p>运算符和汇总类函数（aggregate functions，后面还会学到）也可以配合使用。如<code>x / sum(x)</code>，计算占总数的比例，<code>y - mean(y)</code>计算的是和平均值得差别。</p></li>
<li><p>模块运算符（Modular arithmetic）: <code>%/%</code> (整除) 和 <code>%%</code> (求余数), 即： <code>x == y * (x %/% y) + (x %% y)</code>. 模块运算符是很有用的工具，因为它能够把除法中涉及的整数提取出来用如飞机数据中，可通过<code>dep_time</code> 计算<code>hour</code> 和 <code>minute</code> :</p>
<pre class="r"><code>transmute(flights,
  dep_time,
  hour = dep_time %/% 60,
  minute = dep_time %% 60
)</code></pre>
<pre><code>## # A tibble: 336,776 x 3
##    dep_time  hour minute
##       &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;
##  1      517     8     37
##  2      533     8     53
##  3      542     9      2
##  4      544     9      4
##  5      554     9     14
##  6      554     9     14
##  7      555     9     15
##  8      557     9     17
##  9      557     9     17
## 10      558     9     18
## # ... with 336,766 more rows</code></pre>
<pre class="r"><code># 原文中是除以100，按分钟应该是除以60吧？</code></pre></li>
<li><p>对数系列: <code>log()</code>, <code>log2()</code>, <code>log10()</code>。 对数变换起码在两种情况极其有用：一是对付量级差别较大的数据，二是以后再模型一节还会提到的，把倍数关系转变为增减关系。</p>
<p>几个转换方式差别不大，作者推荐使用<code>log2()</code>，因为解释起来比较容易：转换后刻度为1的就是原始数据加倍的，转换后为-1就是原始数据减半的。</p></li>
<li><p>抵消（Offsets）:<code>dplyr</code>包里的 <code>lead()</code> 和 <code>lag()</code>，可以计算前后移位值（leading or lagging values）。这可以有利于计算 （running differences），例如<code>x - lag(x)</code>，或者发现数值变化(<code>x != lag(x))</code>。在配合 <code>group_by()</code>函数应用时尤为有用，稍后会学到。</p>
<pre class="r"><code>(x &lt;- 1:10)  # 写上括号就是即赋值又在控制台显示。</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<pre class="r"><code>lag(x)</code></pre>
<pre><code>##  [1] NA  1  2  3  4  5  6  7  8  9</code></pre>
<pre class="r"><code>lead(x)</code></pre>
<pre><code>##  [1]  2  3  4  5  6  7  8  9 10 NA</code></pre></li>
<li><p>累积及循环汇总（Cumulative and rolling aggregates）:R基本包提供累积求和、product，最小值和最大值: <code>cumsum()</code>, <code>cumprod()</code>, <code>cummin()</code>, <code>cummax()</code>; dplyr包提供累积求平均值 <code>cummean()</code>。如果需要循环汇总(rolling aggregates)，例如 在 rolling window求和, 尝试 RcppRoll包。</p>
<pre class="r"><code>x</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<pre class="r"><code>cumsum(x)</code></pre>
<pre><code>##  [1]  1  3  6 10 15 21 28 36 45 55</code></pre>
<pre class="r"><code>cummean(x)</code></pre>
<pre><code>##  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5</code></pre></li>
<li><p>逻辑比较, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>!=</code>, 之前学过。如果进行比较复杂的比较，最好新建中间变量，这样不容易出错且容易检查。</p></li>
<li><p>排序: 有很多中排序方法，可以从 <code>min_rank()</code>开始熟悉，它可以完成大部分排序，如 1st, 2nd, 2nd, 4th。默认把最小值给排成最小序号，加上 <code>desc(x)</code> 可以反向排序。</p>
<pre class="r"><code>y &lt;- c(1, 2, 2, NA, 3, 4)
min_rank(y)</code></pre>
<pre><code>## [1]  1  2  2 NA  4  5</code></pre>
<pre class="r"><code>min_rank(desc(y))</code></pre>
<pre><code>## [1]  5  3  3 NA  2  1</code></pre>
<p>如果<code>min_rank()</code>不合适用，还有几个其他函数，如 <code>row_number()</code>, <code>dense_rank()</code>, <code>percent_rank()</code>, <code>cume_dist()</code>, <code>ntile()</code>，用法详见帮助文档。</p>
<pre class="r"><code>row_number(y)</code></pre>
<pre><code>## [1]  1  2  3 NA  4  5</code></pre>
<pre class="r"><code>dense_rank(y)</code></pre>
<pre><code>## [1]  1  2  2 NA  3  4</code></pre>
<pre class="r"><code>percent_rank(y)</code></pre>
<pre><code>## [1] 0.00 0.25 0.25   NA 0.75 1.00</code></pre>
<pre class="r"><code>cume_dist(y)</code></pre>
<pre><code>## [1] 0.2 0.6 0.6  NA 0.8 1.0</code></pre></li>
</ul>
</div>
<div id="-1" class="section level3">
<h3>练习</h3>
<ol style="list-style-type: decimal">
<li><p>飞机数据集里的 <code>dep_time</code> 和 <code>sched_dep_time</code> 看起来很方便，不过不便于计算，因为不是连续的数字，是个很别扭的格式，后两位是分钟，到了60进位，前面的是小时，所以$dep_time和arr_time不能直接加减，把这两个变量进行转换，从凌晨开始按分钟计算。</p>
<pre class="r"><code># 用取整方法，把分钟和小时分开，再加起来。
mutate(flights,
   dep_time = (dep_time %/% 100) * 60 + (dep_time %% 100),
   sched_dep_time = (sched_dep_time %/% 100) * 60 + (sched_dep_time %% 100))</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      317            315         2      830
##  2  2013     1     1      333            329         4      850
##  3  2013     1     1      342            340         2      923
##  4  2013     1     1      344            345        -1     1004
##  5  2013     1     1      354            360        -6      812
##  6  2013     1     1      354            358        -4      740
##  7  2013     1     1      355            360        -5      913
##  8  2013     1     1      357            360        -3      709
##  9  2013     1     1      357            360        -3      838
## 10  2013     1     1      358            360        -2      753
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code># 用余数
mutate(flights,
   dep_time = 60 * floor(dep_time/100) + (dep_time - floor(dep_time/100) * 100),
   sched_dep_time = 60 * floor(sched_dep_time/100) + (sched_dep_time - floor(sched_dep_time/100) * 100))</code></pre>
<pre><code>## # A tibble: 336,776 x 19
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      317            315         2      830
##  2  2013     1     1      333            329         4      850
##  3  2013     1     1      342            340         2      923
##  4  2013     1     1      344            345        -1     1004
##  5  2013     1     1      354            360        -6      812
##  6  2013     1     1      354            358        -4      740
##  7  2013     1     1      355            360        -5      913
##  8  2013     1     1      357            360        -3      709
##  9  2013     1     1      357            360        -3      838
## 10  2013     1     1      358            360        -2      753
## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre></li>
<li><p>比较 <code>air_time</code> 和 <code>arr_time - dep_time</code>，你感觉应该是什么结果，实际结果如何？如何修正？</p>
<pre class="r"><code># 本来以为应该一样，结果差别不小。首先因为有些飞机是凌晨前起飞，凌晨后到达，这样减出来的数值肯定不对，甚至会有很多负值。更重要的是上一题也讲过，这里的时间格式有点奇怪，60进位的数字，按正常方法加减肯定不行，得变成连续数字，和air_time一样，都换成纯分钟。
# 意外又发生了，本来以为都换成分钟，能够减出来和air time一样的值，可最后得到的数还是不一样，vary

flights %&gt;% 
  mutate(dep_time = (dep_time %/% 100) * 60 + (dep_time %% 100),
     arr_time = (arr_time %/% 100) * 60 + (arr_time %% 100)) %&gt;%
  transmute((arr_time - dep_time) - air_time)</code></pre>
<pre><code>## # A tibble: 336,776 x 1
##    `(arr_time - dep_time) - air_time`
##                                 &lt;dbl&gt;
##  1                                -34
##  2                                -30
##  3                                 61
##  4                                 77
##  5                                 22
##  6                                -44
##  7                                 40
##  8                                 19
##  9                                 21
## 10                                -23
## # ... with 336,766 more rows</code></pre></li>
<li><p>Compare <code>dep_time</code>, <code>sched_dep_time</code>, and <code>dep_delay</code>. How would you expect those three numbers to be related?</p>
<pre class="r"><code># 和上面的题一样，需要先变成分钟</code></pre></li>
<li><p>Find the 10 most delayed flights using a ranking function. How do you want to handle ties? Carefully read the documentation for <code>min_rank()</code>.</p></li>
<li><p>What does <code>1:3 + 1:10</code> return? Why?</p>
<pre class="r"><code>1:3 + 1:10</code></pre>
<pre><code>## Warning in 1:3 + 1:10: longer object length is not a multiple of shorter
## object length</code></pre>
<pre><code>##  [1]  2  4  6  5  7  9  8 10 12 11</code></pre>
<pre class="r"><code># 循环匹配，最后不够一次就拉倒，有个警告不是整倍数。</code></pre></li>
<li><p>R语言中提供什么三角函数（trigonometric）？</p>
<pre class="r"><code>?Trig</code></pre></li>
</ol>
</div>
</div>
<div id="-summarise" class="section level2">
<h2>使用 <code>summarise()</code>函数进行分类汇总</h2>
<p>介绍的最后一个函数是 <code>summarise()</code>，它把数据框汇总成<strong>单独一行</strong>。</p>
<pre class="r"><code>summarise(flights, delay = mean(dep_delay, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 1 x 1
##      delay
##      &lt;dbl&gt;
## 1 12.63907</code></pre>
<p>(稍后会讲 <code>na.rm = TRUE</code> 的意思。)</p>
<p><code>summarise()</code> 本身用处不太多，当和 <code>group_by()</code> 配合使用时才会充分散发光辉。配合使用后，计算对象从整个数据框变成了不同的分组，之后在dplyr语境下将会自动按组汇总。例如，如果我们按日期分类，然后运行和上面完全一样的函数，将会得到每日平均值。</p>
<pre class="r"><code>by_day &lt;- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day     delay
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;
##  1  2013     1     1 11.548926
##  2  2013     1     2 13.858824
##  3  2013     1     3 10.987832
##  4  2013     1     4  8.951595
##  5  2013     1     5  5.732218
##  6  2013     1     6  7.148014
##  7  2013     1     7  5.417204
##  8  2013     1     8  2.553073
##  9  2013     1     9  2.276477
## 10  2013     1    10  2.844995
## # ... with 355 more rows</code></pre>
<p>结合 <code>group_by()</code> 和 <code>summarise()</code> ，将提供给我们工作中使用最多的按组汇总功能。但在深入研究之前，我们先介绍一个很牛逼的新概念：管道（the pipe）.</p>
<div class="section level3">
<h3>使用管道进行多步操作</h3>
<p>假设我们想探索每个地方飞行距离和平均延误时间之间的关系，使用学过的dpl包相关知识，你可能会写出这样的代码：</p>
<pre class="r"><code>by_dest &lt;- group_by(flights, dest)
delay &lt;- summarise(by_dest,
  count = n(),
  dist = mean(distance, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE)
)
delay &lt;- filter(delay, count &gt; 20, dest != &quot;HNL&quot;)

# It looks like delays increase with distance up to ~750 miles 
# and then decrease. Maybe as flights get longer there&#39;s more 
# ability to make up delays in the air?
ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
  geom_point(aes(size = count), alpha = 1/3) +
  geom_smooth(se = FALSE)</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39;</code></pre>
<p><img src="/post/2017-10-09-r-for-data-science-04-data-transformation_files/figure-html/unnamed-chunk-55-1.png" width="576" /></p>
<p>准备数据分为三步:</p>
<ol style="list-style-type: decimal">
<li><p>按飞行目的地对数据分组。</p></li>
<li><p>汇总各组距离、延误时间、飞机数目等。Summarise to compute distance, average delay, and number of flights.</p></li>
<li><p>删除噪音点和Honolulu机场，因为它是离群值，太远。</p></li>
</ol>
<p>这样的代码太复杂，每个中间变量都需要赋值，而且用过就没用了。命名不容易还得费脑子，降低工作速度。</p>
<p>管道功能应运而生，专治这种毛病， <code>%&gt;%</code>:</p>
<pre class="r"><code>delays &lt;- flights %&gt;% 
  group_by(dest) %&gt;% 
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %&gt;% 
  filter(count &gt; 20, dest != &quot;HNL&quot;)</code></pre>
<p>以上专注于变换过程，不管变换的是什么，代码也更容易阅读。读起来是一段富有逻辑且必要的语句：分组、汇总、筛选。在这里，管道函数一个比较合适的读音是“then”，汉语可以读“然后”。</p>
<p>上面代码的意思， <code>x %&gt;% f(y)</code> 即 <code>f(x, y)</code> ， <code>x %&gt;% f(y) %&gt;% g(z)</code> 即 <code>g(f(x, y), z)</code> 以此类推。通过管道函数的使用，可以避免复杂的嵌套，讲多步操作按照从左到右、从上到下的阅读习惯写出来。我们今后将会经常使用管道函数，提高代码可读性，后面还会在管道函数一章进一步详细讲解。</p>
<p>使用管道函数是融入tidyverse大家庭的重要标准。但在ggplot2里没法用，因为ggplot2编写于作者发现管道函数之前。不幸的是，下一代可以应用管道函数的ggplot2、ggvis，目前还没编写好。</p>
</div>
<div id="-1" class="section level3">
<h3>缺失值</h3>
<p>上面我们设置了一个参数是 <code>na.rm</code> ，那么如果没有特意设置它会怎么样？</p>
<pre class="r"><code>flights %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(mean = mean(dep_delay))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day  mean
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
##  1  2013     1     1    NA
##  2  2013     1     2    NA
##  3  2013     1     3    NA
##  4  2013     1     4    NA
##  5  2013     1     5    NA
##  6  2013     1     6    NA
##  7  2013     1     7    NA
##  8  2013     1     8    NA
##  9  2013     1     9    NA
## 10  2013     1    10    NA
## # ... with 355 more rows</code></pre>
<p>发现，算出一堆缺失值来！这是因为本函数遵从大部分汇总函数的原则：如果汇总对象里有缺失值，则汇总结果也是缺失值。幸运的是，所有这些函数里都有一个 <code>na.rm</code> 参数，能够在计算时排除缺失值。</p>
<pre class="r"><code>flights %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(mean = mean(dep_delay, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day      mean
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;
##  1  2013     1     1 11.548926
##  2  2013     1     2 13.858824
##  3  2013     1     3 10.987832
##  4  2013     1     4  8.951595
##  5  2013     1     5  5.732218
##  6  2013     1     6  7.148014
##  7  2013     1     7  5.417204
##  8  2013     1     8  2.553073
##  9  2013     1     9  2.276477
## 10  2013     1    10  2.844995
## # ... with 355 more rows</code></pre>
<p>此例中，缺失值代表取消的航班，我们也可以先把取消的航班去掉。我们将保存这个数据以备之后使用。</p>
<pre class="r"><code>not_cancelled &lt;- flights %&gt;% 
  filter(!is.na(dep_delay), !is.na(arr_delay))

not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(mean = mean(dep_delay))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day      mean
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;
##  1  2013     1     1 11.435620
##  2  2013     1     2 13.677802
##  3  2013     1     3 10.907778
##  4  2013     1     4  8.965859
##  5  2013     1     5  5.732218
##  6  2013     1     6  7.145959
##  7  2013     1     7  5.417204
##  8  2013     1     8  2.558296
##  9  2013     1     9  2.301232
## 10  2013     1    10  2.844995
## # ... with 355 more rows</code></pre>
</div>
<div class="section level3">
<h3>计数</h3>
<p>做任何汇总的时候，做个计数都挺有用，可以直接计数(<code>n()</code>)，也可以计数不含缺失值的 (<code>sum(!is.na(x))</code>)。这样你能确定有没有基于很小的数据量得出结论。例如，我们看看不同班次的航班，那个平均延误时间最长。</p>
<pre class="r"><code>delays &lt;- not_cancelled %&gt;% 
  group_by(tailnum) %&gt;% 
  summarise(
    delay = mean(arr_delay)
  )

ggplot(data = delays, mapping = aes(x = delay)) + 
  geom_freqpoly(binwidth = 10)</code></pre>
<p><img src="/post/2017-10-09-r-for-data-science-04-data-transformation_files/figure-html/unnamed-chunk-60-1.png" width="672" /></p>
<p>哟，发现有些飞机 <em>平均</em> 延误为5小时 (300 分钟)！</p>
<p>实际上，另有隐情。我们可以通过对航班数和平均延误做个散点图来看看到底发生了什么：</p>
<pre class="r"><code>delays &lt;- not_cancelled %&gt;% 
  group_by(tailnum) %&gt;% 
  summarise(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(data = delays, mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)</code></pre>
<p><img src="/post/2017-10-09-r-for-data-science-04-data-transformation_files/figure-html/unnamed-chunk-61-1.png" width="672" /></p>
<p>如我们所料，飞机数目越少的时候，延误时间变异越大。本图形状非常典型：当你对平均值和分组规模作图时，你会发现变异随着样本规模变大而降低。</p>
<p>分析此类作图时，最好先把少数派剔除出来，从而更好的发现主要趋势，而不是被少数派所影响。以下代码即实现这个目标，还会展示如何把ggplot2和dplyr结合运用。但是这里不能用管道函数（ <code>%&gt;%</code>），需要用 <code>+</code>，当然等你熟悉了以后，这也挺方便的。</p>
<pre class="r"><code>delays %&gt;% 
  filter(n &gt; 25) %&gt;% 
  ggplot(mapping = aes(x = n, y = delay)) + 
    geom_point(alpha = 1/10)</code></pre>
<p><img src="/post/2017-10-09-r-for-data-science-04-data-transformation_files/figure-html/unnamed-chunk-62-1.png" width="672" /></p>
<hr />
<p>RStudio 小窍门: 一个有用的快捷键是 Cmd/Ctrl + Shift + P。它的作用是重新运行你上次运行过的代码框（chunk）。当尝试不同n值得时候这挺有用，比如先用Cmd/Ctrl + Enter运行，然后修改一下n的值，然后再用 Cmd/Ctrl + Shift + P，这时就会重新运行刚才的代码了。——虽然我实在不懂为什么没有再摁一下Cmd/Ctrl + Enter。</p>
<hr />
<p>此类模式还有一种常见的变种。让我们看看棒球比赛中击球手（batters）的表现与其在比赛中出现的次数是如何相关的。这里使用 <strong>Lahman</strong> 包中的数据，计算每个主力击球手的平均急求表现（击球次数/尝试次数）。</p>
<p>当我把技巧</p>
<p>When I plot the skill of the batter (measured by the batting average, <code>ba</code>) against the number of opportunities to hit the ball (measured by at bat, <code>ab</code>), you see two patterns:</p>
<ol style="list-style-type: decimal">
<li><p>As above, the variation in our aggregate decreases as we get more data points.</p></li>
<li><p>There’s a positive correlation between skill (<code>ba</code>) and opportunities to hit the ball (<code>ab</code>). This is because teams control who gets to play, and obviously they’ll pick their best players.</p></li>
</ol>
<pre class="r"><code># Convert to a tibble so it prints nicely
batting &lt;- as_tibble(Lahman::Batting)

batters &lt;- batting %&gt;% 
  group_by(playerID) %&gt;% 
  summarise(
    ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    ab = sum(AB, na.rm = TRUE)
  )

batters %&gt;% 
  filter(ab &gt; 100) %&gt;% 
  ggplot(mapping = aes(x = ab, y = ba)) +
    geom_point() + 
    geom_smooth(se = FALSE)</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;gam&#39;</code></pre>
<p><img src="/post/2017-10-09-r-for-data-science-04-data-transformation_files/figure-html/unnamed-chunk-63-1.png" width="672" /></p>
<p>This also has important implications for ranking. If you naively sort on <code>desc(ba)</code>, the people with the best batting averages are clearly lucky, not skilled:</p>
<pre class="r"><code>batters %&gt;% 
  arrange(desc(ba))</code></pre>
<pre><code>## # A tibble: 18,915 x 3
##     playerID    ba    ab
##        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt;
##  1 abramge01     1     1
##  2 banisje01     1     1
##  3 bartocl01     1     1
##  4  bassdo01     1     1
##  5 berrijo01     1     1
##  6 birasst01     1     2
##  7 bruneju01     1     1
##  8 burnscb01     1     1
##  9 cammaer01     1     1
## 10  campsh01     1     1
## # ... with 18,905 more rows</code></pre>
<p>You can find a good explanation of this problem at <a href="http://varianceexplained.org/r/empirical_bayes_baseball/" class="uri">http://varianceexplained.org/r/empirical_bayes_baseball/</a> and <a href="http://www.evanmiller.org/how-not-to-sort-by-average-rating.html" class="uri">http://www.evanmiller.org/how-not-to-sort-by-average-rating.html</a>.</p>
</div>
<div id="summarise-funs" class="section level3">
<h3>Useful summary functions</h3>
<p>Just using means, counts, and sum can get you a long way, but R provides many other useful summary functions:</p>
<ul>
<li><p>Measures of location: we’ve used <code>mean(x)</code>, but <code>median(x)</code> is also useful. The mean is the sum divided by the length; the median is a value where 50% of <code>x</code> is above it, and 50% is below it.</p>
<p>It’s sometimes useful to combine aggregation with logical subsetting. We haven’t talked about this sort of subsetting yet, but you’ll learn more about it in [subsetting].</p>
<pre class="r"><code>not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(
    avg_delay1 = mean(arr_delay),
    avg_delay2 = mean(arr_delay[arr_delay &gt; 0]) # the average positive delay
  )</code></pre>
<pre><code>## # A tibble: 365 x 5
## # Groups:   year, month [?]
##     year month   day avg_delay1 avg_delay2
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;      &lt;dbl&gt;      &lt;dbl&gt;
##  1  2013     1     1 12.6510229   32.48156
##  2  2013     1     2 12.6928879   32.02991
##  3  2013     1     3  5.7333333   27.66087
##  4  2013     1     4 -1.9328194   28.30976
##  5  2013     1     5 -1.5258020   22.55882
##  6  2013     1     6  4.2364294   24.37270
##  7  2013     1     7 -4.9473118   27.76132
##  8  2013     1     8 -3.2275785   20.78909
##  9  2013     1     9 -0.2642777   25.63415
## 10  2013     1    10 -5.8988159   27.34545
## # ... with 355 more rows</code></pre></li>
<li><p>Measures of spread: <code>sd(x)</code>, <code>IQR(x)</code>, <code>mad(x)</code>. The mean squared deviation, or standard deviation or sd for short, is the standard measure of spread. The interquartile range <code>IQR()</code> and median absolute deviation <code>mad(x)</code> are robust equivalents that may be more useful if you have outliers.</p>
<pre class="r"><code># Why is distance to some destinations more variable than to others?
not_cancelled %&gt;% 
  group_by(dest) %&gt;% 
  summarise(distance_sd = sd(distance)) %&gt;% 
  arrange(desc(distance_sd))</code></pre>
<pre><code>## # A tibble: 104 x 2
##     dest distance_sd
##    &lt;chr&gt;       &lt;dbl&gt;
##  1   EGE   10.542765
##  2   SAN   10.350094
##  3   SFO   10.216017
##  4   HNL   10.004197
##  5   SEA    9.977993
##  6   LAS    9.907786
##  7   PDX    9.873299
##  8   PHX    9.862546
##  9   LAX    9.657195
## 10   IND    9.458066
## # ... with 94 more rows</code></pre></li>
<li><p>Measures of rank: <code>min(x)</code>, <code>quantile(x, 0.25)</code>, <code>max(x)</code>. Quantiles are a generalisation of the median. For example, <code>quantile(x, 0.25)</code> will find a value of <code>x</code> that is greater than 25% of the values, and less than the remaining 75%.</p>
<pre class="r"><code># When do the first and last flights leave each day?
not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(
    first = min(dep_time),
    last = max(dep_time)
  )</code></pre>
<pre><code>## # A tibble: 365 x 5
## # Groups:   year, month [?]
##     year month   day first  last
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  2013     1     1   517  2356
##  2  2013     1     2    42  2354
##  3  2013     1     3    32  2349
##  4  2013     1     4    25  2358
##  5  2013     1     5    14  2357
##  6  2013     1     6    16  2355
##  7  2013     1     7    49  2359
##  8  2013     1     8   454  2351
##  9  2013     1     9     2  2252
## 10  2013     1    10     3  2320
## # ... with 355 more rows</code></pre></li>
<li><p>Measures of position: <code>first(x)</code>, <code>nth(x, 2)</code>, <code>last(x)</code>. These work similarly to <code>x[1]</code>, <code>x[2]</code>, and <code>x[length(x)]</code> but let you set a default value if that position does not exist (i.e. you’re trying to get the 3rd element from a group that only has two elements). For example, we can find the first and last departure for each day:</p>
<pre class="r"><code>not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(
    first_dep = first(dep_time), 
    last_dep = last(dep_time)
  )</code></pre>
<pre><code>## # A tibble: 365 x 5
## # Groups:   year, month [?]
##     year month   day first_dep last_dep
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1       517     2356
##  2  2013     1     2        42     2354
##  3  2013     1     3        32     2349
##  4  2013     1     4        25     2358
##  5  2013     1     5        14     2357
##  6  2013     1     6        16     2355
##  7  2013     1     7        49     2359
##  8  2013     1     8       454     2351
##  9  2013     1     9         2     2252
## 10  2013     1    10         3     2320
## # ... with 355 more rows</code></pre>
<p>These functions are complementary to filtering on ranks. Filtering gives you all variables, with each observation in a separate row:</p>
<pre class="r"><code>not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  mutate(r = min_rank(desc(dep_time))) %&gt;% 
  filter(r %in% range(r))</code></pre>
<pre><code>## # A tibble: 770 x 20
## # Groups:   year, month, day [365]
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1     2356           2359        -3      425
##  3  2013     1     2       42           2359        43      518
##  4  2013     1     2     2354           2359        -5      413
##  5  2013     1     3       32           2359        33      504
##  6  2013     1     3     2349           2359       -10      434
##  7  2013     1     4       25           2359        26      505
##  8  2013     1     4     2358           2359        -1      429
##  9  2013     1     4     2358           2359        -1      436
## 10  2013     1     5       14           2359        15      503
## # ... with 760 more rows, and 13 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, r &lt;int&gt;</code></pre></li>
<li><p>Counts: You’ve seen <code>n()</code>, which takes no arguments, and returns the size of the current group. To count the number of non-missing values, use <code>sum(!is.na(x))</code>. To count the number of distinct (unique) values, use <code>n_distinct(x)</code>.</p>
<pre class="r"><code># Which destinations have the most carriers?
not_cancelled %&gt;% 
  group_by(dest) %&gt;% 
  summarise(carriers = n_distinct(carrier)) %&gt;% 
  arrange(desc(carriers))</code></pre>
<pre><code>## # A tibble: 104 x 2
##     dest carriers
##    &lt;chr&gt;    &lt;int&gt;
##  1   ATL        7
##  2   BOS        7
##  3   CLT        7
##  4   ORD        7
##  5   TPA        7
##  6   AUS        6
##  7   DCA        6
##  8   DTW        6
##  9   IAD        6
## 10   MSP        6
## # ... with 94 more rows</code></pre>
<p>Counts are so useful that dplyr provides a simple helper if all you want is a count:</p>
<pre class="r"><code>not_cancelled %&gt;% 
  count(dest)</code></pre>
<pre><code>## # A tibble: 104 x 2
##     dest     n
##    &lt;chr&gt; &lt;int&gt;
##  1   ABQ   254
##  2   ACK   264
##  3   ALB   418
##  4   ANC     8
##  5   ATL 16837
##  6   AUS  2411
##  7   AVL   261
##  8   BDL   412
##  9   BGR   358
## 10   BHM   269
## # ... with 94 more rows</code></pre>
<p>You can optionally provide a weight variable. For example, you could use this to “count” (sum) the total number of miles a plane flew:</p>
<pre class="r"><code>not_cancelled %&gt;% 
  count(tailnum, wt = distance)</code></pre>
<pre><code>## # A tibble: 4,037 x 2
##    tailnum      n
##      &lt;chr&gt;  &lt;dbl&gt;
##  1  D942DN   3418
##  2  N0EGMQ 239143
##  3  N10156 109664
##  4  N102UW  25722
##  5  N103US  24619
##  6  N104UW  24616
##  7  N10575 139903
##  8  N105UW  23618
##  9  N107US  21677
## 10  N108UW  32070
## # ... with 4,027 more rows</code></pre></li>
<li><p>Counts and proportions of logical values: <code>sum(x &gt; 10)</code>, <code>mean(y == 0)</code>. When used with numeric functions, <code>TRUE</code> is converted to 1 and <code>FALSE</code> to 0. This makes <code>sum()</code> and <code>mean()</code> very useful: <code>sum(x)</code> gives the number of <code>TRUE</code>s in <code>x</code>, and <code>mean(x)</code> gives the proportion.</p>
<pre class="r"><code># How many flights left before 5am? (these usually indicate delayed
# flights from the previous day)
not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(n_early = sum(dep_time &lt; 500))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day n_early
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
##  1  2013     1     1       0
##  2  2013     1     2       3
##  3  2013     1     3       4
##  4  2013     1     4       3
##  5  2013     1     5       3
##  6  2013     1     6       2
##  7  2013     1     7       2
##  8  2013     1     8       1
##  9  2013     1     9       3
## 10  2013     1    10       3
## # ... with 355 more rows</code></pre>
<pre class="r"><code># What proportion of flights are delayed by more than an hour?
not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(hour_perc = mean(arr_delay &gt; 60))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day  hour_perc
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;      &lt;dbl&gt;
##  1  2013     1     1 0.07220217
##  2  2013     1     2 0.08512931
##  3  2013     1     3 0.05666667
##  4  2013     1     4 0.03964758
##  5  2013     1     5 0.03486750
##  6  2013     1     6 0.04704463
##  7  2013     1     7 0.03333333
##  8  2013     1     8 0.02130045
##  9  2013     1     9 0.02015677
## 10  2013     1    10 0.01829925
## # ... with 355 more rows</code></pre></li>
</ul>
</div>
<div id="grouping-by-multiple-variables" class="section level3">
<h3>Grouping by multiple variables</h3>
<p>When you group by multiple variables, each summary peels off one level of the grouping. That makes it easy to progressively roll up a dataset:</p>
<pre class="r"><code>daily &lt;- group_by(flights, year, month, day)
(per_day   &lt;- summarise(daily, flights = n()))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day flights
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
##  1  2013     1     1     842
##  2  2013     1     2     943
##  3  2013     1     3     914
##  4  2013     1     4     915
##  5  2013     1     5     720
##  6  2013     1     6     832
##  7  2013     1     7     933
##  8  2013     1     8     899
##  9  2013     1     9     902
## 10  2013     1    10     932
## # ... with 355 more rows</code></pre>
<pre class="r"><code>(per_month &lt;- summarise(per_day, flights = sum(flights)))</code></pre>
<pre><code>## # A tibble: 12 x 3
## # Groups:   year [?]
##     year month flights
##    &lt;int&gt; &lt;int&gt;   &lt;int&gt;
##  1  2013     1   27004
##  2  2013     2   24951
##  3  2013     3   28834
##  4  2013     4   28330
##  5  2013     5   28796
##  6  2013     6   28243
##  7  2013     7   29425
##  8  2013     8   29327
##  9  2013     9   27574
## 10  2013    10   28889
## 11  2013    11   27268
## 12  2013    12   28135</code></pre>
<pre class="r"><code>(per_year  &lt;- summarise(per_month, flights = sum(flights)))</code></pre>
<pre><code>## # A tibble: 1 x 2
##    year flights
##   &lt;int&gt;   &lt;int&gt;
## 1  2013  336776</code></pre>
<p>Be careful when progressively rolling up summaries: it’s OK for sums and counts, but you need to think about weighting means and variances, and it’s not possible to do it exactly for rank-based statistics like the median. In other words, the sum of groupwise sums is the overall sum, but the median of groupwise medians is not the overall median.</p>
</div>
<div id="ungrouping" class="section level3">
<h3>Ungrouping</h3>
<p>If you need to remove grouping, and return to operations on ungrouped data, use <code>ungroup()</code>.</p>
<pre class="r"><code>daily %&gt;% 
  ungroup() %&gt;%             # no longer grouped by date
  summarise(flights = n())  # all flights</code></pre>
<pre><code>## # A tibble: 1 x 1
##   flights
##     &lt;int&gt;
## 1  336776</code></pre>
</div>
<div id="exercises-1" class="section level3">
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Brainstorm at least 5 different ways to assess the typical delay characteristics of a group of flights. Consider the following scenarios:</p>
<ul>
<li><p>A flight is 15 minutes early 50% of the time, and 15 minutes late 50% of the time.</p></li>
<li><p>A flight is always 10 minutes late.</p></li>
<li><p>A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of the time.</p></li>
<li><p>99% of the time a flight is on time. 1% of the time it’s 2 hours late.</p></li>
</ul>
<p>Which is more important: arrival delay or departure delay?</p></li>
<li><p>Come up with another approach that will give you the same output as <code>not_cancelled %&gt;% count(dest)</code> and <code>not_cancelled %&gt;% count(tailnum, wt = distance)</code> (without using <code>count()</code>).</p></li>
<li><p>Our definition of cancelled flights (<code>is.na(dep_delay) | is.na(arr_delay)</code> ) is slightly suboptimal. Why? Which is the most important column?</p></li>
<li><p>Look at the number of cancelled flights per day. Is there a pattern? Is the proportion of cancelled flights related to the average delay?</p></li>
<li><p>Which carrier has the worst delays? Challenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about <code>flights %&gt;% group_by(carrier, dest) %&gt;% summarise(n())</code>)</p></li>
<li><p>What does the <code>sort</code> argument to <code>count()</code> do. When might you use it?</p></li>
</ol>
</div>
</div>
<div id="grouped-mutates-and-filters" class="section level2">
<h2>Grouped mutates (and filters)</h2>
<p>Grouping is most useful in conjunction with <code>summarise()</code>, but you can also do convenient operations with <code>mutate()</code> and <code>filter()</code>:</p>
<ul>
<li><p>Find the worst members of each group:</p>
<pre class="r"><code>flights_sml %&gt;% 
  group_by(year, month, day) %&gt;%
  filter(rank(desc(arr_delay)) &lt; 10)</code></pre>
<pre><code>## # A tibble: 3,306 x 7
## # Groups:   year, month, day [365]
##     year month   day dep_delay arr_delay distance air_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
##  1  2013     1     1       853       851      184       41
##  2  2013     1     1       290       338     1134      213
##  3  2013     1     1       260       263      266       46
##  4  2013     1     1       157       174      213       60
##  5  2013     1     1       216       222      708      121
##  6  2013     1     1       255       250      589      115
##  7  2013     1     1       285       246     1085      146
##  8  2013     1     1       192       191      199       44
##  9  2013     1     1       379       456     1092      222
## 10  2013     1     2       224       207      550       94
## # ... with 3,296 more rows</code></pre></li>
<li><p>Find all groups bigger than a threshold:</p>
<pre class="r"><code>popular_dests &lt;- flights %&gt;% 
  group_by(dest) %&gt;% 
  filter(n() &gt; 365)
popular_dests</code></pre>
<pre><code>## # A tibble: 332,577 x 19
## # Groups:   dest [77]
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ... with 332,567 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre></li>
<li><p>Standardise to compute per group metrics:</p>
<pre class="r"><code>popular_dests %&gt;% 
  filter(arr_delay &gt; 0) %&gt;% 
  mutate(prop_delay = arr_delay / sum(arr_delay)) %&gt;% 
  select(year:day, dest, arr_delay, prop_delay)</code></pre>
<pre><code>## # A tibble: 131,106 x 6
## # Groups:   dest [77]
##     year month   day  dest arr_delay   prop_delay
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;        &lt;dbl&gt;
##  1  2013     1     1   IAH        11 1.106740e-04
##  2  2013     1     1   IAH        20 2.012255e-04
##  3  2013     1     1   MIA        33 2.350026e-04
##  4  2013     1     1   ORD        12 4.239594e-05
##  5  2013     1     1   FLL        19 9.377853e-05
##  6  2013     1     1   ORD         8 2.826396e-05
##  7  2013     1     1   LAX         7 3.444441e-05
##  8  2013     1     1   DFW        31 2.817951e-04
##  9  2013     1     1   ATL        12 3.996017e-05
## 10  2013     1     1   DTW        16 1.157257e-04
## # ... with 131,096 more rows</code></pre></li>
</ul>
<p>A grouped filter is a grouped mutate followed by an ungrouped filter. I generally avoid them except for quick and dirty manipulations: otherwise it’s hard to check that you’ve done the manipulation correctly.</p>
<p>Functions that work most naturally in grouped mutates and filters are known as window functions (vs. the summary functions used for summaries). You can learn more about useful window functions in the corresponding vignette: <code>vignette(&quot;window-functions&quot;)</code>.</p>
<div id="exercises-2" class="section level3">
<h3>Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Refer back to the lists of useful mutate and filtering functions. Describe how each operation changes when you combine it with grouping.</p></li>
<li><p>Which plane (<code>tailnum</code>) has the worst on-time record?</p></li>
<li><p>What time of day should you fly if you want to avoid delays as much as possible?</p></li>
<li><p>For each destination, compute the total minutes of delay. For each, flight, compute the proportion of the total delay for its destination.</p></li>
<li><p>Delays are typically temporally correlated: even once the problem that caused the initial delay has been resolved, later flights are delayed to allow earlier flights to leave. Using <code>lag()</code> explore how the delay of a flight is related to the delay of the immediately preceding flight.</p></li>
</ol>
</div>
</div>

    </div>
  </div>

</article>



<div class="article-container">
  <h3>Related</h3>
  <ul>
    
    <li><a href="/post/r-for-data-science-03-some-basics/">学习R for data science - 03 一些基础操作</a></li>
    
    <li><a href="/post/r-for-data-science-02-data-visualization/">学习R for data science - 02 数据可视化</a></li>
    
    <li><a href="/post/learn-r-for-data-science-01-data-visualization/">学习R for data science - 01 数据可视化</a></li>
    
  </ul>
</div>


<div class="container">
  <nav>
  <ul class="pager">
    
    <li class="previous"><a href="/post/r-for-data-science-03-some-basics/"><span
      aria-hidden="true">&larr;</span> 学习R for data science - 03 一些基础操作</a></li>
    

    
    <li class="next"><a href="/post/analyzing-text-data-on-web/">使用R语言分析网络文本数据——以小学生分析过的苏轼为例 <span
      aria-hidden="true">&rarr;</span></a></li>
    
  </ul>
</nav>

</div>

<div class="article-container">
  

</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 王强 &middot; 

      Powered by the <a href="https://github.com/gcushen/hugo-academic" target="_blank">Academic
      theme</a> for <a href="http://gohugo.io" target="_blank">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha512-3P8rXCuGJdNZOnUx/03c1jOTnMn3rP63nBip5gOP2qmUh5YAdVAvFZ1E+QLZZbC1rtMrQb+mah3AfYW11RUrWA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    <script src="/js/hugo-academic.js"></script>
    

    
    
      
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
      

      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    

  </body>
</html>

